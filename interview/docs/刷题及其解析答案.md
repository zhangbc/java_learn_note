# 笔试刷题集

## Leetcode题集

#### 9. 回文数（☑️）

> 原题链接：https://leetcode-cn.com/problems/palindrome-number/

**题目描述**

>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**思路分析**

> 由于整数的特殊性，如果为负数，则易知不是回文数（因为整数的末尾不可能出现符号）。
>
> 方法一：此题最容易想到的就是把数字转成字符串 `str`，然后用双指针法(`low`，`high`)进行首尾遍历，当 `str[low] != str[high]` 说明不是回文；否则进行下一轮，`low++，high--` ，直到`low >= high` 循环结束。
>
> 方法二：方法一是常规的字符串解法，没有充分利用本题的整数这一条件，回文数是指整数的前部分（负数除外）和后半部分形成对称，也就是说只要将整数拆成位数相等（如果整数的奇数位去中间位）的两部分并且将后半部分翻转与前半部分相比，如相等则说明是回文数，否则不是。需要处理的问题有：1）整数翻转，定义一个新的整型变量 `reverse`，循环每次取 `x` 的个位数，然后 `reverse = reverse * 10 + x % 10`，同时需要将 `x = x / 10`，这样可以将`x`进行翻转；2）拆分整数`x`为两部分，本题只需要判断前半部分和翻转后的后半分部分是否相等即可，所以循环的终止条件是 `x <= reverse`，当整数 `x` 为偶数位时两数相等；当整数 `x` 为奇数位时 `x < reverse`，因为多出的中间位被添加到 `reverse` 的末尾，所以最终判断是否为回文数的条件应该为 `x == reverse || x == reverse / 10` ；3）注意特殊情况，如果 `x` 的个位数为0，那么易知整数不是回文数，2）中的最终判断条件会判定 `x = 10` 为 `true` ，这是最容易忽略的一点。

**参考代码**

- 方法一：转字符串法，时间复杂度为 $O(n/2)$，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public boolean isPalindrome(int x) {
        String value = String.valueOf(x);
        int low = 0;
        int high = value.length() - 1;
        while (low < high) {
            if (value.charAt(low) != value.charAt(high)) {
                return false;
            }
            
            low++;
            high--;
        }
        
        return true;
    }
}
```

运行结果如下：

![转字符串法](images/leetcode_20200514125544.png)

- 方法二：反转后半部分数字，时间复杂度为 $O(log_{10}n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean isPalindrome(int x) {
        boolean flag = x < 0 || (x % 10 ==0 && x != 0);
        if (flag) {
            return false;
        }

        int reverse = 0;
        while (x > reverse) {
            reverse = reverse * 10 + x % 10;
            x /= 10;
        }

        return x == reverse || x == reverse / 10;
    }
}
```

运行结果如下：

![反转后半部分数字](images/leetcode_20200514121403.png)

#### 10. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

运行结果如下：

![转字符串法]



#### 28. 实现 strStr()（☑️）

> 标题：【Leetcode刷题】字符串模式匹配算法知多少
>
> 原题链接：https://leetcode-cn.com/problems/implement-strstr/

**题目描述**

> 实现 `strStr()` 函数。
>
> 给定一个 `haystack` 字符串和一个 `needle` 字符串，在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
>
> 说明：
>
> > 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
> >
> > 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

**思路分析**

> 方法一/二：此题最先也是最容易想到的是暴力解法，但是实践证明，在 `Java` 提交中通不过，逐一判断超时，增加条件即满足首尾相等在进行判断相等，即可优化解，提交可以通过；
>
> 方法三：通过对暴力解分析，利用 `Java` 字符串截取方法，通过逐一比较子字符串可得；
>
> 方法四：前三种方法实质都是通过逐一比较子字符串求解，其实还有更进一步优化，分析发现其实并不是所有长度为 `needle.length()` 需要比较，可以利用双指针判断，具体做法是：定义两个指针 `p`，`q` 分别指向 `haystack`，`needle`，从首字符开始，如果不相等，则移动 `p`；如果两个指针指向相等，则同时移动下一位，直至 `p` 指向 `needle` 的尾字符，如果仍相等，则说明找到其位置，程序结束；否则需要从不相等的位置开始同时向前回溯（`p` 再次指向 `needle` 的首字符为止）；如此循环即可；
>
> 方法五：`Rabin Karp` 算法，其思路是先生成窗口内子串的哈希码，然后再跟 `needle` 字符串的哈希码做比较。如何在常数时间生成子串的哈希码？ 这里需要涉及到**滚动哈希**：常数时间生成哈希码，利用滑动窗口的特性，每次滑动都有一个元素进，一个出，生成一个长度为 `L` 数组的哈希码，需要 $O(L)$ 时间。算法步骤如下：
>
> > 计算子字符串 `haystack.substring(0, L)` 和 `needle.substring(0, L)` 的哈希值。
> >
> > 从起始位置开始遍历：从第一个字符遍历到第 N - L 个字符；
> >
> > 根据前一个哈希值计算滚动哈希；
> >
> > 如果子字符串哈希值与 `needle` 字符串哈希值相等，返回滑动窗口起始位置。
> >
> > 返回 -1，这时候 `haystack` 字符串中不存在 `needle` 字符串。
>
> 方法六：`BM`（`Boyer-Moore`）算法，其思想是有模式串中不存在的字符，那么肯定不匹配，往后多移动几位，提高效率，遵循**坏字符**规则，**好后缀**规则。
>
> > 1）**坏字符规则**：当文本串中的某个字符跟模式串的某个字符不匹配时，称文本串中的这个失配字符为**坏字符**，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果"坏字符"不包含在模式串之中，则最右出现位置为-1；
> >
> > 2）**好后缀规则**：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。
>
> 本题采用坏字符规则，具体做法是：首先针对模式串 `needle` 构造模式串的数组表（哈希表） `suffix` （本题是字符串默认为基本字符，`ASCII` 码是8位），然后从 `haystack` 的首字符循环遍历长度为 `needle.length()` 的子串， 跳跃为 `skip`， 用 `needle` 从后往前匹配，如果整个模式串匹配成功则 `skip=0` 终止程序，否则 `skip = j - suffix[haystack.charAt(i + j)]`，直到最后一个子串，如果未匹配成功，最后返回 `-1`。
>
> 方法七：`KMP` (`Knuth-Morris-Pratt `) 算法，基本思路如下：
>
> > 假设现在文本串 `S` 匹配到 `i` 位置，模式串 `P` 匹配到 `j` 位置：
> >
> > > 1）如果 `j = -1`，或者当前字符匹配成功（即 `S[i] == P[j]`），都令 `i++`，`j++`，继续匹配下一个字符；
> > >
> > > 2）如果 `j != -1`，且当前字符匹配失败（即 `S[i] != P[j]`），则令 `i` 不变，`j = next[j]`。此举意味着失配时，模式串 `P` 相对于文本串 `S` 向右移动了 `j - next [j]` 位。
> > >
> > > `next` 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如`next [j] = k`，代表 `j` 之前的字符串中有最大长度为 `k` 的相同前缀后缀。
>
> 算法步骤：首先求解模式串 `P` 的 `next` 数组：定义长度为 `P.length()` 的数组 `next`，遍历模式串 `P`，取 `i=-1,j=0`，若 `P.charAt(j)` 与 `P.charAt(i)` 相等，则 `j` 的下一个跳到 `i` 的下一个处，否则退回至 `next[i]`，循环结束即可得`next` 数组；然后同时循环遍历文本串 `S` 和 模式串 `P` ，根据上述思路即可完成。
>
> 方法八：`Sunday`算法，是 `Daniel M.Sunday` 于1990年提出的字符串模式匹配，其核心思想是：在匹配过程中，模式串发现不匹配时，算法能跳过尽可能多的字符以进行下一步的匹配，从而提高了匹配效率。`Sunday` 算法思想跟 `BM` 算法很相似，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符，如果该字符没有在匹配串中出现则直接跳过，即移动步长= 匹配串长度+1；否则，同 `BM` 算法一样其移动步长=匹配串中最右端的该字符到末尾的距离+1。
>
> 算法步骤：定义模式串的哈希表（本题采用数组），循环遍历 `haystack`，每次取长度为 `needle.length()` 的子串与`needle`比较，如果相等则返回对应的下标，程序结束；否则，判断 `haystack.charAt(i + needle.length())` 是否在 `needle` 中：若在则移动步长 `skip` 为1；若不在，则移动步长 `skip` 为 `i + needle.length()`，直到最后一个子串，如果未匹配成功，最后返回 `-1`。
>
> 测试用例组：
>
> > 1）`haystack` = "`hello`", `needle` = "`ll`"
> >
> > 2）`haystack` = "`aaaaa`", `needle` = "`bba`"
> >
> > 3）`haystack` = "`a`", `needle` = "`a`"
> >
> > 4）`haystack` = "`aaa`", `needle` = "`aaaa`"
> >
> > 5）`haystack` = "`mississippi`", `needle` = "`a`" 
> >
> > 6）`haystack` = "`mississippi`", `needle` = "`issi`"

**参考代码**

- ~~方法一：暴力解法，**[提交时，超出时间限制]**，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。~~

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        for (int i = 0; i < haystack.length(); i++) {
            if (haystack.charAt(i) == needle.charAt(0)) {
                boolean result = isSubStr(haystack, needle, i);
                if (result) {
                    return i;
                }
            }
        }
        
        return -1;
    }

    private boolean isSubStr(String haystack, String needle, int i) {
        for (int j = 0; j < needle.length(); j++) {
            if (i == haystack.length()) {
                return false;
            }
            
            if (haystack.charAt(i) != needle.charAt(j)) {
                return false;
            }
            
            i++;
        }
        
        return true;
    }
}
```

运行结果如下：

![暴力法](images/leetcode_20200530142931.png)

- 方法二：暴力优化解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        int len = needle.length();
        for (int i = 0; i < haystack.length(); i++) {
            if (haystack.charAt(i) == needle.charAt(0) 
                    && i + len - 1 < haystack.length()
                    && haystack.charAt(i + len - 1) == needle.charAt(len - 1)) {
                boolean result = isSubStr(haystack, needle, i);
                if (result) {
                    return i;
                }
            }
        }
        
        return -1;
    }

    private boolean isSubStr(String haystack, String needle, int i) {
        for (int j = 0; j < needle.length(); j++) {
            if (i == haystack.length()) {
                return false;
            }

            if (haystack.charAt(i) != needle.charAt(j)) {
                return false;
            }
            
            i++;
        }
        
        return true;
    }
}
```

运行结果如下：

![暴力优化法](images/leetcode_20200530143536.png)

- 方法三：字符串截取+逐一比较子字符串，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。


```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        for (int i = 0; i < haystack.length(); i++) {
            if (i + needle.length() <= haystack.length() 
            && haystack.substring(i, i + needle.length()).equals(needle)) {
                return i;
            }
        }

        return -1;
    }
}
```

运行结果如下：

![字符串截取+逐一比较子字符串](images/leetcode_20200530145406.png)

- 方法四：双指针法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        int p = 0, q, curLen;
        while (p + needle.length() - 1 < haystack.length()) {
            // 不相等，则移动p
            while (p + needle.length() - 1 < haystack.length()
                    && haystack.charAt(p) != needle.charAt(0)) {
                p++;
            }

            q = 0;
            curLen = 0;
            // 两个指针指向相等，则同时移动下一位
            while (p < haystack.length() && q < needle.length()
                    && haystack.charAt(p) == needle.charAt(q)) {
                p++;
                q++;
                curLen++;
            }

            if (curLen == needle.length()) {
                return p - curLen;
            }
            
            // 向前回溯
            p = p - curLen + 1;
        }

        return -1;
    }
}
```

运行结果如下：

![双指针法](images/leetcode_20200530154251.png)

- 方法五：`Rabin Karp` 算法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        if (haystack.length() < needle.length()) {
            return -1;
        }

        // 设置滚动哈希函数的基值--本题取a
        int base = 26;
        long module = (long)Math.pow(2, 31);

        // 计算Hash值
        long hash = 0, refHash = 0;
        for (int i = 0; i < needle.length(); i++) {
            hash = (hash * base + charToInt(haystack, i)) % module;
            refHash = (refHash * base + charToInt(needle, i)) % module;
        }

        // 首部匹配成功
        if (hash == refHash) {
            return 0;
        }

        // 计算最高位
        long bit = 1;
        for (int i = 0; i < needle.length(); i++) {
            bit = (bit * base) % module;
        }
        
        // 遍历并判断查找
        for (int i = 1; i < haystack.length() - needle.length() + 1; i++) {
            hash = (hash * base - charToInt( haystack, i - 1) * bit
                    + charToInt(haystack, i + needle.length() - 1)) % module;
            if (hash == refHash) {
                return i;
            }
        }

        return -1;
    }

    private int charToInt(String string, int i) {
        return string.charAt(i) - 'a';
    }
}
```

运行结果如下：

![RabinKarp](images/leetcode_20200530191937.png)

- 方法六：`BM` 算法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        // 构建模式串的数组表（哈希表）
        int[] suffix = generateSuffix(needle);

        int skip;
        for (int i = 0; i <= haystack.length() - needle.length(); i += skip) {
            skip = 0;
            for (int j = needle.length() - 1; j >= 0; j--) {
                if (needle.charAt(j) != haystack.charAt(i + j)) {
                    // 计算跳跃步数
                    skip = j - suffix[haystack.charAt(i + j)];
                    skip = skip < 1 ? 1 : skip;
                    break;
                }
            }

            if (skip == 0) {
                return i;
            }
        }
        return -1;
    }

    private int[] generateSuffix(String needle) {
        int max = 128;
        int[] suffix = new int[max];
        for (int i = 0; i < max; i++) {
            suffix[i] = -1;
        }

        for (int i = 0; i < needle.length(); i++) {
            suffix[needle.charAt(i)] = i;
        }
        
        return suffix;
    }
}
```

运行结果如下：

![BM算法](images/leetcode_20200530212634.png)

- 方法七：`KMP` 算法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        int[] next = getNext(needle);
        int i = 0, j = 0;
        while (i < haystack.length() && j < needle.length()) {
            if (j == -1 || haystack.charAt(i) == needle.charAt(j)) {
                i++;
                j++;
            } else {
                j = next[j];
            }
        }

        return j == needle.length() ? i - j : -1;
    }

    private int[] getNext(String pattern) {
        int[] next = new int[pattern.length()];
        next[0] = -1;
        int i = -1, j = 0;
        while (j < pattern.length() - 1) {
            if (i == -1 || pattern.charAt(j) == pattern.charAt(i)) {
                // 若相等，则j的下一个跳到i的下一个处
                next[++j] = ++i;
                if (pattern.charAt(j) == pattern.charAt(i)) {
                    //若继续相等，则再往前跳
                    next[j] = next[i];
                }
            } else {
                //不相等则移回到i处
                i = next[i];
            }
        }

        return next;
    }
}
```

运行结果如下：

![KMP算法](images/leetcode_20200530232301.png)

- 方法八：`Sunday`算法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        // 构建模式串的数组表（哈希表）
        int[] suffix = generateSuffix(needle);

        int skip;
        for (int i = 0; i <= haystack.length() - needle.length(); i += skip) {
            if (needle.equals(haystack.substring(i, i + needle.length()))) {
                return i;
            } else {
                skip = i + needle.length() < haystack.length()
                        && suffix[haystack.charAt(i + needle.length())] == -1
                        ? i + needle.length() : 1;
            }
        }
        return -1;
    }

    private int[] generateSuffix(String needle) {
        int max = 128;
        int[] suffix = new int[max];
        for (int i = 0; i < max; i++) {
            suffix[i] = -1;
        }

        for (int i = 0; i < needle.length(); i++) {
            suffix[needle.charAt(i)] = i;
        }

        return suffix;
    }
}
```

运行结果如下：

![Sunday算法](images/leetcode_20200531003038.png)

**参考资料**

> [官方题解](https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode/)
>
> [Rabin-Karp算法](https://blog.csdn.net/seacowtech/article/details/79256299)
>
> [子串查找算法-Rabin-Karp](https://www.jianshu.com/p/68cbe955103e)
>
> [面试算法之字符串匹配算法，Rabin-Karp算法详解](https://blog.csdn.net/tyler_download/article/details/52457108?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)
>
> [从头到尾彻底理解KMP（2014年8月22日版）](https://blog.csdn.net/v_july_v/article/details/7041827)
>
> [字符串匹配算法（BM）](https://blog.csdn.net/qq_21201267/article/details/92799488)
>
> [KMP算法和BM算法的java简单实现](https://www.jianshu.com/p/dad121ffc46f)

#### 35. 搜索插入位置（☑️）

> 原题链接：https://leetcode-cn.com/problems/search-insert-position/

**题目描述**

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 你可以假设数组中无重复元素。

**思路分析**

> 分析题意，可以理解为给一个已排好序的数组“插入”一个数，求解其插入位置。这里给出两种解法。
>
> 方法一：常规解法，逐一遍历每一个元素并与目标值比较，如果目标值大于前一个数而小于等与后一个数，那么应返回后一个数的位置，即为插入位置；如果目标值小于第一个元素应返回0；如果目标值大于最后一个元素应返回数组的长度，即为插入位置；
>
> 方法二：二分查找法，进一步探究方法一，其实质就是查找，那么可以优化查找算法，从而可以应用二分法查找，降低时间复杂度。

**参考代码**

- 方法一：常规解法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        if (nums == null || nums.length < 1) {
            return 0;
        }

        for (int i = 0; i < nums.length; i++) {
            if (target <= nums[i]) {
                return i;
            }
        }

        return nums.length;
    }
}
```

运行结果如下：

![常规解法](images/leetcode_20200601215744.png)

- 方法二：二分查找法，其时间复杂度为 $O(log{n})$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        if (nums == null || nums.length < 1) {
            return 0;
        }

        int low = 0, high = nums.length - 1, mid;
        while (low <= high) {
            mid = (low + high) / 2;
            if (target < nums[mid]) {
                high = mid - 1;
            } else if (target == nums[mid]) {
                return mid;
            } else {
                low = mid + 1;
            }
        }
        
        return low;
    }
}
```

运行结果如下：

![二分查找法](images/leetcode_20200601215004.png)

#### 46. 全排列

> 原题链接：https://leetcode-cn.com/problems/permutations/

**题目描述**

> 给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

**思路分析**

> 方法一：（递归法）从集合中依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理，从而得到所有元素的全排列。
> 
> 方法二：（字典序排序） 给定两个偏序集 `A` 和 `B`, (`a`,`b`) 和 (`a′`,`b′`) 属于笛卡尔集 `A × B`，则 **字典序** 定义为(`a`,`b`) `≤` (`a′`,`b′`) 当且仅当 `a < a′` 或 (`a = a′` 且 `b ≤ b′`)。 所以给定两个字符串，逐个字符比较，那么先出现较小字符的那个串字典顺序小，如果字符一直相等，较短的串字典顺序小。例如： `abc` < `abcd` < `abde` < `afab`。
> 需要这样的一个算法，使得：
>
>> - 起点： 字典序最小的排列，1-`n` ，例如 12345；
>> - 终点： 字典序最大的排列， `n`-1， 例如 54321；
>> - 过程： 从当前排列生成字典序刚好比它大的下一个排列。

> `next_permutation` 算法
>
> > - 定义：**升序**：相邻两个位置 $a_i {\lt} a_{i +1}$，$a_i$ 称作该升序的首位；
> > - 步骤（二找、一交换、一翻转）：
> >   1）找到排列中最后（最右）一个升序的首位位置 $i$， $x =a_i$；
> >   2）找到排列中第 `i` 位右边最后一个比 $a_i$ 大的位置 $j$，$y = a_j$；
> >   3）交换 $x$，$y$；
> >   4）把第 $(i + 1)$ 位到最后的部分翻转。
>
> 方法三：回溯法
>
> ```java
> result = []
> def backtrack(路径, 选择列表):
>     if 满足结束条件:
>         result.add(路径)
>         return
>     
>     for 选择 in 选择列表:
>         做选择
>         backtrack(路径, 选择列表)
>         撤销选择
> ```
>
> 方法四：深度优先遍历（DFS）


**参考代码**

- 方法一：递归法，时间复杂度为 $O(n!)$，空间复杂度为 $O(n)$。

```java
import java.util.ArrayList;
import java.util.List;

public class Solution {

    List<List<Integer>> array = new ArrayList<>(16);

    public List<List<Integer>> permute(int[] nums) {
        if (nums == null || nums.length < 1) {
            return array;
        }

        calcAllPermute(nums, 0, nums.length - 1);
        return array;
    }

    private void calcAllPermute(int[] nums, int from, int to) {
        if (to < 0) {
            return;
        }
        
        if (from == to) {
            List<Integer> items = new ArrayList<>(16);
            for (int i = 0; i <= to; i++) {
                items.add(nums[i]);
            }
            array.add(items);
        } else {
            for (int i = from; i <= to; i++) {
                swap(nums, i, from);
                calcAllPermute(nums, from + 1, to);
                swap(nums, i, from);
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

运行结果如下：

![递归法](images/leetcode_20200905164743.png)

- 方法二：字典序排序，时间复杂度为 $O(n!)$，空间复杂度为 $O(n)$。

```java
import java.util.List;

class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> array = new ArrayList<>(16);
        if (nums == null || nums.length < 1) {
            return array;
        }

        Arrays.sort(nums);

        while (true) {
            List<Integer> temp = new ArrayList<>(16);
            for (int item: nums) {
                temp.add(item);
            }
            array.add(temp);
            
            if (!calcAllPermutationDic(nums)) {
                break;
            }
        }

        return array;
    }

    private boolean calcAllPermutationDic(int[] nums) {
        int i, index = 2;
        // ① 找到排列中最后(最右)一个升序的首位位置i，x=a_i
        for(i = nums.length - index; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                break;
            }
        }

        // 已经找到所有排序
        if(i < 0) {
            return false;
        }

        int k;
        // ② 找到排列中第i个右边最后一个比a_i大的位置j，y=a_j
        for(k = nums.length - 1; k > i; k--) {
            if (nums[k] > nums[i]) {
                break;
            }
        }

        // ③ 交换x，y
        nums[i] += nums[k];
        nums[k] = nums[i] - nums[k];
        nums[i] -= nums[k];

        // ④ 把第(i+1)位到最后的部分翻转
        for (int j = i + 1, m = nums.length - 1; j < m; j++, m--) {
            nums[j] += nums[m];
            nums[m] = nums[j] - nums[m];
            nums[j] -= nums[m];
        }
        return true;
    }
}
```

运行结果如下：

![字典排序](images/leetcode_20200905170916.png)

- 方法三：回溯法，时间复杂度为 $O(n!)$，空间复杂度为 $O(n)$。

```java
import java.util.List;

/**
 * def backtrack(路径, 选择列表):
 *      if 满足结束条件:
 *          result.add(路径)
 *          return
 *
 *     for 选择 in 选择列表:
 *         做选择
 *         backtrack(路径, 选择列表)
 *         撤销选择
 *
 *  @author zhangbocheng
 */
class Solution {
    private List<List<Integer>> array = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        if (nums == null || nums.length < 1) {
            return array;
        }

        Stack<Integer> track = new Stack<>();
        backTrack(nums, track);
        return array;
    }

    private void backTrack(int[] nums, Stack<Integer> track) {
        if (track.size() == nums.length) {
            array.add(new ArrayList<>(track));
            return;
        }

        for (int i: nums) {
            if (track.contains(i)) {
                continue;
            }

            track.push(i);
            backTrack(nums, track);
            track.pop();
        }
    }
}
```

运行结果如下：

![回溯法](images/leetcode_20200905173700.png)

- 方法四：`DFS` 法，时间复杂度为 $O(nlogn)$，空间复杂度为 $O(n)$。

```java
import java.util.List;

class Solution {
    private List<List<Integer>> array = new ArrayList<>(16);
    public List<List<Integer>> permute(int[] nums) {
        if (nums == null || nums.length < 1) {
            return array;
        }

        Stack<Integer> depth = new Stack<>();
        boolean[] visited = new boolean[nums.length];
        dfs(nums, 0, depth, visited);
        return array;
    }

    private void dfs(int[] nums, int depth, Stack<Integer> path, boolean[] visited) {
        if (depth == nums.length) {
            array.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (visited[i]) {
                continue;
            }

            path.add(nums[i]);
            visited[i] = true;
            dfs(nums, depth + 1, path, visited);
            path.pop();
            visited[i] = false;
        }
    }
}
```

运行结果如下：

![DFS法](images/leetcode_20200905175100.png)

#### 60. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

运行结果如下：

![转字符串法](images/leetcode_20200905200300.png)



#### 283. 移动零 

> 原题链接：https://leetcode-cn.com/problems/move-zeroes/

**题目描述**

> 给定一个数组 `nums`，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> ==说明：==
>
> > 必须在原数组上操作，不能拷贝额外的数组。
> > 尽量减少操作次数。

**思路分析**

> 减少操作次数即要求最小的移动代价，每个需要移动的元素仅仅移动一次即可。换个思路看，既然是把 0 移动到末尾，那只需要留下非零元素，然后在数组末尾部分用0填充即可。

**参考代码**

- 方法一：最小移动法，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        if (nums == null || nums.length < 1) {
            return;
        }
        
        int i = 0, j = 0;
        for (; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[j++] = nums[i];
            }
        }
        
        while (j < nums.length) {
            nums[j++] = 0;
        }
    }
}
```

运行结果如下：

![移动零](images/leetcode_20200905120343.png)

#### 453. 最小移动次数使数组元素相等

> 原题链接：https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/

**题目描述**

> 给定一个长度为 $n$ 的 **非空** 整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 $n - 1$ 个元素增加 1。
>
> 示例：
>
> > 输入：[1,2,3]
> >
> > 输出：3
> >
> > ==解释==
> > 只需要3次移动（注意每次移动会增加两个元素的值）：
> > [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]

**思路分析**

> 方法一：（数学法）分析题目，通过移动增加使得所有元素最终相等，换而言之，就是求最小移动次数使得数组中最小元素和最大元素达到相等。每次固定其中最大的一个元素，其他元素移动一次，这样保证移动次数最小，假定最大值固定，那么就可以得出一个结论：移动次数就是数组中每个元素与最小元素的差的总和。**误区**：移动次数为数组中最大元素与每个元素的差的总和。测试用例：[1, 1, 2147483647]
>
> 方法二：（动态规划）考虑有序数组 $a$。假设，直到 $i-1$ 位置的元素都已经相等，只需要考虑 $i$ 位的元素，将差值 $diff=a[i]-a[i-1]$ 加到总移动次数上，使得第 $i$ 位也相等，$moves=moves+diff$。
>
> 但当继续这一步时，$a[i]$ 之后的元素也会被增加 $diff$，亦即 $a[j]=a[j]+diff$，其中 $j>i$。
>
> 但当实现本方法时，不需要对这样的 $a[j]$ 进行增加。相反把 $moves$ 的数量增加到当前元素（$a[i]$）中，$a'[i]=a[i]+moves$。
>
> 简而言之，我们对数列进行排序，一直更新 $moves$ 以使得直到当前的元素相等，而不改变除了当前元素之外的元素。在整个数组扫描完毕后，$moves$ 即为答案。
>

**参考代码**

- 方法一：数学法，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。 

```java
class Solution {
    public int minMoves(int[] nums) {
        int min = nums[0];
        for (int item: nums) {
            if (min > item) {
                min = item;
            }
        }

        int sum = 0;
        for (int item: nums) {
            sum += item - min;
        }

        return sum;
    }
}
```

运行结果：

![数学法](images/leetcode_20200904102621.png)

方法二：动态规划，时间复杂度为 $O(nlogn)$，空间复杂度为 $O(1)$。

```java
public class Solution {
    public int minMoves(int[] nums) {
        int moves = 0, diff;
        Arrays.sort(nums);

        for (int i = 1; i < nums.length; i++) {
            diff = moves + nums[i] - nums[i - 1];
            nums[i] += moves;
            moves += diff;
        }

        return moves;
    }
}
```

![动态规划](images/leetcode_20200904112608.png)

#### 560. 和为K的子数组（☑️）

> 原题链接：https://leetcode-cn.com/problems/subarray-sum-equals-k/

**题目描述**

> 给定一个整数数组和一个整数 $k$，你需要找到该数组中和为 $k$ 的连续的子数组的个数。
>

**思路分析**

> 方法一：此题最容易想到的暴力解法即枚举法，从数组的第一个元素开始，累加求和 `sum` 直到数组的最后一个元素结束（数组是无序，需要求的是连续的子数组，千万不能满足找到了第一个子数组就跳出循环，这是很容易忽略的地方），用一个整型变量`counts` 记录 `sum == k` 的个数，然后对第 `2～n` 做同样的处理，最后把每次循环后得到的 `counts` 累加便是本题的答案。注意此方法解题需要注意的几个特例（需要处理的细节问题）：
>
> > 1）子数组可能只含一个元素，如 `[1,1,3] 3`；
> >
> > 2）子数组可能就是整个数组，如 `[28,54,7,-70,22,65,-6] 100`；
> >
> > 3）以某个元素开始的满足条件的子数组可能不止一个，如 `[0,0,0,0,0,0,0,0,0,0] 0`。
>
> 方法二：前缀和+哈希优化法，此方法最不容易想到。对方法一进行优化分析，定义一个新的整型数组 `pre` ，用 `pre[i]` 记录数组的前 `i` 项和，容易得到递推公式：
> $$
> pre[i] = pre[i-1]+nums[i]
> $$
> 那么在 `[j ... i]` 中，和为 `k` 为的条件可表示为：
> $$
> pre[i]-pre[j-1]==k
> $$
> 所以考虑以 `i` 结尾的和为 `k` 的连续子数组个数时只要统计有多少个前缀和为 `pre[i]-k` 的 `pre[j]` 即可。为了简化 `pre` 操作可以用 `hashMap` 存储，定义为 `map`，`key` 为和值 `pre[i]`，`value` 为对应 `pre[i]` 出现的次数，从左往右边更新 `map` 边计算答案，那么以 `i` 结尾的答案 `map[pre[i]−k]` 即可在 $O(1)$ 时间内得到，最终答案即为所有下标结尾的和为 `k` 的子数组个数之和。
>

**参考代码**

- 方法一：暴力枚举法，时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0;
        if (nums == null || nums.length < 1) {
            return count;
        }

        for (int i = 0; i < nums.length; i++) {
            count += getSums(nums, i, k);
        }
        
        return count;
    }

    private int getSums(int[] nums, int i, int k) {
        int counts = 0;
        int sum = nums[i];
        if (sum == k) {
            counts++;
        }

        while (i < nums.length - 1) {
            sum += nums[++i];
            if (sum == k) {
                counts++;
            }
        }

        return counts;
    }
}
```

运行结果如下：

![暴力枚举法](images/leetcode_20200515012859.png)

- 方法二：前缀和+哈希优化，时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0, pre = 0;
        if (nums == null || nums.length < 1) {
            return count;
        }

        HashMap<Integer, Integer> map = new HashMap<>(16);
        map.put(0,1);
        for (int i = 0; i < nums.length; i++) {
            pre += nums[i];
            if (map.containsKey(pre - k)) {
                count += map.get(pre - k);
            }

            map.put(pre, map.getOrDefault(pre, 0) + 1);
        }

        return count;
    }
}
```

运行结果如下：

![前缀和哈希优化](images/leetcode_20200515102934.png)

#### 680. 验证回文字符串 Ⅱ（☑️）

> 原题链接：https://leetcode-cn.com/problems/valid-palindrome-ii/

**题目描述**

> 给定一个非空字符串 `s`，**最多**删除一个字符。判断是否能成为回文字符串。
>
> **注意：** 字符串只包含从 `a-z` 的小写字母。字符串的最大长度是50000。

**思路分析**

> 这题是回文判断的一个变式题，主要还是考查对双指针的理解。用 `low` 和 `high` 分别指向字符串 `s` 的首位和末尾，如果二者相等，则执行 `low++` ，`high--` ；如果不相等，则需要分两种情况：
>
> > 1）第 `low + 1` 位与第 `high` 位相等，依次循环判断，如果为回文字符串，则返回 `true` ，否则返回 `false` ，记为 `usedLeft`；
> >
> > 2）第 `low` 位与第 `high - 1` 位相等，依次循环判断，如果为回文字符串，则返回 `true` ，否则返回 `false` ，记为 `usedRight`。
>
> 最后，综合不等情况判断，只要不等情况1）和2）中有一个符合回文字符串，那么都应该返回 `true`，即判断条件应为  `usedLeft||usedRight`	；跳出循环如果还没返回值，说明是标准的回文串，应返回 `true`。
>
> 做题过程中，对不等判断很容易忽视情况1）和2）是**或**的关系判断， 即忽略判断两边都可以的情况（**贪心算法思想**）。如测试实例：`"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga"`。

**参考代码**

- 双指针法，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean validPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return false;
        }

        int low = 0, high = s.length() - 1;
        while (low < high) {
            if (s.charAt(low) == s.charAt(high)) {
                low++;
                high--;
                continue;
            }

            int left = low + 1, right = high - 1;
            boolean usedLeft = isPalindrome(s, left, high);
            boolean usedRight = isPalindrome(s, low, right);
            return usedLeft || usedRight;
        }

        return true;
    }

    private boolean isPalindrome(String s, int low, int high) {
        while (low < high) {
            if (s.charAt(low) != s.charAt(high)) {
                return false;
            }
            
            low++;
            high--;
        }
        
        return true;
    }
}
```

运行结果如下：

![双指针法](images/leetcode_20200519104743.png)

#### 876. 链表的中间结点

- 方法一：常规思路法

```java
/**
 * 876. 链表的中间结点
 * 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。
 * 如果有两个中间结点，则返回第二个中间结点。
 *
 * 示例 1：
 * 输入：[1,2,3,4,5]
 * 输出：此列表中的结点 3 (序列化形式：[3,4,5]
 * 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
 * 注意，我们返回了一个 ListNode 类型的对象 ans，这样：
 * ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
 *
 * 示例 2：
 * 输入：[1,2,3,4,5,6]
 * 输出：此列表中的结点 4 (序列化形式：[4,5,6])
 * 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
 * 提示：
 * 给定链表的结点数介于 1 和 100 之间。
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/3/23 10:38
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode p = head;
        int count = 0;
        while (p != null) {
            count++;
            p = p.next;
        }

        int mid = count / 2 + 1;
        count = 1;
        p = head;
        while (count < mid) {
            count++;
            p = p.next;
        }
        return p;
    }
}
```

- 方法二：数组法（官方解）

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */

/**
 * 876. 链表的中间结点
 * 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。
 * 如果有两个中间结点，则返回第二个中间结点。
 *
 * 示例 1：
 * 输入：[1,2,3,4,5]
 * 输出：此列表中的结点 3 (序列化形式：[3,4,5]
 * 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
 * 注意，我们返回了一个 ListNode 类型的对象 ans，这样：
 * ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
 *
 * 示例 2：
 * 输入：[1,2,3,4,5,6]
 * 输出：此列表中的结点 4 (序列化形式：[4,5,6])
 * 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
 * 提示：
 * 给定链表的结点数介于 1 和 100 之间。
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/3/23 10:38
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        final int COUNT = 100;
        ListNode[] arrayNodes = new ListNode[COUNT];
        int count = 0;
        while (head != null) {
            arrayNodes[count++] = head;
            head = head.next;
        }
        return arrayNodes[count / 2];
    }
}
```

- 方法三：快慢指针法

```java

```





#### 1431. 拥有最多糖果的孩子（☑️）

> 原题链接：https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/

**题目描述**

> 给你一个数组 `candies` 和一个整数 `extraCandies` ，其中 `candies[i]` 代表第 `i` 个孩子拥有的糖果数目。
>
> 对每一个孩子，检查是否存在一种方案，将额外的 `extraCandies` 个糖果分配给孩子们之后，此孩子有**最多**的糖果。注意，允许有多个孩子同时拥有**最多**的糖果数目。
>
> 示例 1：
>
> > 输入：`candies = [2,3,5,1,3], extraCandies = 3`
> > 输出：`[true,true,true,false,true]` 
> > **==解释==**：
> > 孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。
> > 孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
> > 孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。
> > 孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。
> > 孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
>
> 示例 2：
>
> > 输入：`candies = [4,2,1,1,2], extraCandies = 1`
> > 输出：`[true,false,false,false,false]`
> > **==解释==**：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。

**思路分析**

> 对题目理解不透彻的话，强烈建议看示例中解释，很好地帮助我们审了题意，即本题要求是：针对组内每一个小朋友手中糖果`candies[i]` ，若把额外的糖果 `extraCandies` 分配给他，判断能否达到或者超过组内糖果的最大值。因而，解答应分两步走：1）求出组内最大值 `max`；2）针对组内每一个元素加上 `extraCandies` 判断能否达到或超过最大值，若能记为 `true`，否则记为 `false`，将结果保存为一个数组并返回。

**参考代码**

- 常规解法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        List<Boolean> result = new ArrayList<>();
        if (candies == null || candies.length < 1) {
            return result;
        }

        int max = candies[0];
        for (int value: candies) {
            max = Math.max(value, max);
        }

        for (int value: candies) {
            result.add(value + extraCandies >= max);
        }
        
        return result;
    }
}
```

运行结果如下：

![常规解法](images/leetcode_20200601100250.png)

## 企业面试真题

#### 百度2021校园招聘秋招笔试

- 李华的礼物

题目描述：

> 李华顺利地到达了巴黎，他的好友Peter带他开启了他的巴黎之旅。途中，李华遇到了许多心动的纪念品想要带回家，但是他又不想自己太累，而且他买纪念品也有相应的预算k，现给出他心动的纪念品清单：共有n件，其中每件都各有其价格price，重量weight，心动值v(其中心动值为1~5之间的数值)，需要注意的是：在心动值不同的情况下，李华会优先选择心动值大的纪念品；若心动值相同，李华会优先选择比较便宜的纪念品，具体见样例。同时给出李华在保证不累的情况下，最多能拿的物品重量m。在不超过预算并且保证不累的情况下，李华最多可以带几件纪念品回家？
>
> 输入描述：
>
> > 单组输入。
> > 第1行三个正整数，分别为：纪念品件数n，最多能拿的物品重量m，预算k。（n<1e5，m<100，k<10000，k的单位为元，m的重量为kg）
> >
> > 第2行到第n+1行，分别为每件物品的价格price，重量weight，心动值v。（price<10000，weight<100，v为1~5之间的整数，price的单位为元，weight的重量为kg）
>
> 输出描述：
>
> > 在不超过预算并且保证不累的情况下，李华最多可以带回家的纪念品件数。
>
> 样例输入：
>
> > 3 10 1000
> > 100 5 3
> > 50 3 2
> > 300 3 3
>
> 样例输出：
>
> > 2
>
> 解释：
>
> > 李华会优先选择心动值较大的礼物1，3，且总重量和预算都没超过，所以输出为2。

思路分析：

> 其实想明白了挺简单的，当时感觉真脑子短路了。优先按心动值降序，然后心动值相同按照价格升序，考察的核心就是多关键字排序问题。

```java
package com.excise;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

/**
 * 样例输入：
 * 3 10 1000
 * 100 5 3
 * 50 3 2
 * 300 3 3
 *
 * 样例输出：
 * 2
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/9/4 11:50
 */
public class BaiduGift {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String[] row = sc.nextLine().split(" ");
        // 礼物行数
        int n = Integer.parseInt(row[0]);
        // 可承受的总重量
        int m = Integer.parseInt(row[1]);
        // 总预算
        int k = Integer.parseInt(row[2]);

        // 构造礼物矩阵
        List<Gift> giftArray = new ArrayList<>(16);
        while (n > 0) {
            String[] items = sc.nextLine().split(" ");
            Gift gift = new Gift();
            gift.setPrice(Integer.parseInt(items[0]));
            gift.setWeight(Integer.parseInt(items[1]));
            gift.setV(Integer.parseInt(items[2]));
            giftArray.add(gift);
            n--;
        }

        System.out.println(getGiftNumber(giftArray, m, k));
    }

    private static int getGiftNumber(List<Gift> giftArray, int m, int k) {
       List<Gift> gifts = giftArray.stream()
               .sorted(Comparator.comparing(Gift::getV).reversed()
                       .thenComparing(Gift::getPrice)).collect(Collectors.toList());
       int count = 0;
       for (Gift gift: gifts) {
            m -= gift.getWeight();
            k -= gift.getPrice();
            if (m < 0 || k < 0) {
                break;
            }
            count++;
            // 验证
            System.out.printf("%d\t%d\t%d\n", gift.getPrice(), gift.getWeight(), gift.getV());
        }

       return count;
    }

    static class Gift {
        /**
         * 价格
         */
        private int price;
        /**
         * 重量
         */
        private int weight;
        /**
         * 心动值
         */
        private int v;

        public int getPrice() {
            return price;
        }

        public void setPrice(int price) {
            this.price = price;
        }

        public int getWeight() {
            return weight;
        }

        public void setWeight(int weight) {
            this.weight = weight;
        }

        public int getV() {
            return v;
        }

        public void setV(int v) {
            this.v = v;
        }
    }
}
```

- 最小计分

题目描述

> 小度最近在研究一个棋盘游戏，游戏规则如下：
>
> 一个 $N*N$ 的棋盘，每个格子里面填写有1、2、3、4这四个数字中的某一个。最开始时在第1行第1列（左上角）放置一个棋子。每次棋子可以移动至上、下、左、右四个格子中的某一个，每次只能移动一格（允许重复移动到某一个格子），在任何时刻都不允许将棋子移出棋盘。在移动时需要进行计分。如果初始格子中的数字为X，目标格子中的数字为Y，则本次移动计分为|X-Y|（取X-Y的绝对值），即两个格子中的数字之差。 
>
> 现在需要把棋子移动到第N行第N列（右下角），请问能够获得的最小计分为多少？
>
> 输入描述：
>
> > 单组输入。
> > 第1行为N。（1≤N≤100）
> > 接下来N行为一个二维数组，表示棋盘上每一个格子及其对应的数字（正整数）。
>
> 输出描述：
>
> > 输出一个正整数，表示最小计分。
>
> 样例输入：
>
> > 3
> > 1 2 4
> > 1 3 1
> > 1 2 1
>
> 样例输出：
>
> > 2





#### 快手2020校园招聘秋招笔试--算法B试卷

- 算法题1



- 算法题2



- 算法题3：Levenshtein distance

> 时间限制：C/C++ 5秒，其他语言10秒
>
> 空间限制：C/C++ 32M，其他语言64M

已知两个字符串strA和strB，求将strA转换成strB所需的最小编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。

**输入：**

```
FreshMeat
FishAndMeat
```

**输出：**

```
5
```

- 算法题4：单词反转

> 时间限制：C/C++ 1秒，其他语言2秒
>
> 空间限制：C/C++ 32M，其他语言64M

输入一个英文句子, 词之间有1个或者若干个空格，句子以英文标点"."结尾。

要求颠倒该句子中的词语顺序，并且词之间有且只有一个空格，结尾仍然是"."，结尾的"."与前一个单词之间无空格。

**输入：**

```
 I  love     you.
```

**输出：**

```
you love I.
```

- 序列和

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * 序列和：给出一个正整数N和长度L，找出一段长度大于等于L的连续非负整数，他们的和恰好为N。
 * 答案可能有多个，我我们需要找出长度最小的那个。
 * 例如 N = 18 L = 2：
 * 5 + 6 + 7 = 18
 * 3 + 4 + 5 + 6 = 18
 * 都是满足要求的，但是我们输出更短的 5 6 7
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/3/19 10:55
 */
public class Main {
    public static void main(String[] args) {
        Main sum = new Main();
        Scanner scanner = new Scanner(System.in);
        int number = scanner.nextInt();
        int length = scanner.nextInt();
        List<Integer> array = sum.getSequenceSum(number, length);
        StringBuilder resStr = new StringBuilder();
        if (array.size() < 1) {
            resStr.append("No");
        } else {
            for (int i: array) {
                resStr.append(i);
                resStr.append(" ");
            }
        }
        System.out.println(resStr.toString().trim());
    }

    public List<Integer> getSequenceSum(int number, int length) {
        List<Integer> array = new ArrayList<>();
        int maxNumber = 1000000000;
        int maxLength = 100;
        if (number < 1 || number > maxNumber || length < 1 || length > maxLength) {
            return array;
        }

        int mid, i, j, sum;
        while (length <= maxLength) {
            mid = number / length;
            j = length / 2 + 2;
            for (i = mid - j >= 0 ? mid - j : 0; i <= mid + j; i++) {
                sum = (i + i + length - 1) * length / 2;
                if (sum == number) {
                    for (int k = 0; k < length; k++) {
                        array.add(k, i++);
                    }
                    return array;
                }
            }
            length++;
        }

        return array;
    }
}
```

- 合并数组

```java
import java.util.Scanner;

/**
 * 合并数组：请实现一个函数，功能为合并两个升序数组为一个升序数组。
 * 要求：不允许使用原生的 sort、concat 等函数。
 *      输入有多个测试用例，每个测试用例有1-2行，每行都是以英文逗号分隔从小到大排列的数字。
 * 输入：1,5,7,9
 * 2,3,4,6,8,10
 * 输出：1,2,3,4,5,6,7,8,9,10
 *
 * @author zhangbocheng
 */
public class Main {
    public static void main(String[] args) {
        Main merge = new Main();
        Scanner scanner = new Scanner(System.in);
        String str = scanner.nextLine();
        // 考虑只有一行的输入
        if (!scanner.hasNext()) {
            System.out.println(str);
            return;
        }

        String[] array1Str = str.split(",");
        String[] array2Str = scanner.nextLine().split(",");

        int[] array1 = new int[array1Str.length];
        int[] array2 = new int[array2Str.length];
        for (int i = 0; i < array1Str.length; i++) {
            array1[i] = Integer.parseInt(array1Str[i]);
        }

        for (int j = 0; j < array2Str.length; j++) {
            array2[j] = Integer.parseInt(array2Str[j]);
        }

        int[] mergerArray = merge.mergeArrays(array1, array2);
        StringBuilder resStr = new StringBuilder();
        for (int i = 0; i < mergerArray.length; i++) {
            resStr.append(mergerArray[i]);
            if (i < mergerArray.length - 1) {
                resStr.append(",");
            }
        }
        System.out.println(resStr.toString());
    }

    public int[] mergeArrays(int[] array1, int[] array2) {
        if (array1.length < 1 || array2.length < 1) {
            return array1.length > 0 ? array1 : array2;
        }

        int[] merge = new int[array1.length + array2.length];
        int i = 0, j = 0, k = 0;
        while (i < array1.length && j < array2.length) {
            if (array1[i] < array2[j]) {
                merge[k++] = array1[i];
                i++;
            } else {
                merge[k++] = array2[j];
                j++;
            }
        }

        while (i < array1.length) {
            merge[k++] = array1[i++];
        }

        while (j < array2.length) {
            merge[k++] = array2[j++];
        }

        return merge;
    }
}
```



## 剑指offer

应聘者需要具备的素质：

> 1）基础知识扎实全面，包括编程语言，数据结构，算法等；
>
> 2）能写出正确的，完整的，鲁棒性的高质量代码；
>
> 3）能思路清晰地分析、解决复杂问题；
>
> 4）能从时间、空间复杂度两个方面优化算法效率；
>
> 5）具备优秀的沟通能力，学习能力，发散思维能力等。

#### 题3，数组中重复的数字（☑️）

> 原题链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof

**题目描述**

> 在一个长度为 $n$ 的数组 $nums$ 里的所有数字都在 $0$ ~ $n-1$ 的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。

**思路分析**

> 通过阅读提干，不难发现，题目要求是从已知数组中找到重复元素即可。这里列出三种解题思路仅作参考：
>
> > 1）最容易想到的算法自然是先排序后通过依次遍历并与后一个元素相比较找出第一个重复元素即可，易想到但是算法代价大不可取，最优时间复杂度为 $O(nlogn)$ ；
> >
> > 2）利用数据结构--`hash`结构，依次遍历数组中每一个元素，同时将元素放入`hash`中，在放入前先做判断：如果在`hash`存在则说明找到重复元素，否则放入`hash`中，直到遍历完所有元素为止，其时间复杂度为 $O(n)$ ，空间复杂度为 $O(n)$ ；
> >
> > 3）充分利用已知条件“数组里的所有数字都在 $0$ ~ $n-1$ 的范围内”，通过交换元素位置比较可以发现是否有重复元素，为本题最优解，其时间复杂度为 $O(n)$ ：
> >
> > > （1）原地改动数组，空间复杂度为 $O(1)$ ；
> > >
> > > （2）定义新数组，空间复杂度为 $O(n)$ 。

**参考代码**

- 方法一：复制数组，时间复杂度为 $O(n)$ ，空间复杂度为 $O(n)$ 。

````java
class Solution {
    public int findRepeatNumber(int[] nums) {
        int[] arr = new int[nums.length];
        for(int i = 0; i < nums.length; i++) {
            arr[nums[i]]++;
            if (arr[nums[i]] > 1 ) {
                return nums[i];
            }
        }

        return -1;
    }
}
````

运行结果如下：

![复制数组](images/leetcode_20200508234733.png)

- 方法二：原地修改数组，时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != i) {
                if (nums[nums[i]] == nums[i]) {
                    return nums[i];
                }
                
                int temp = nums[nums[i]];
                nums[nums[i]] = nums[i];
                nums[i] = temp;
            }
        }

        return -1;
    }
}
```

运行结果如下：

![原地修改数组](images/leetcode_20200508234657.png)

#### 题4，二维数组中的查找

> 原题链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/

**题目描述：**

> 在一个 $n * m$ 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**思路分析：**

> 方法一：暴力解，双循环遍历二维数组，其时间复杂为 $O(n^2)$ ；
>
> 方法二：题目已明确数组按行按列的递增规律，

**参考代码：**

- 方法一：暴力解，其时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if (matrix.length < 1) {
            return false;
        }

        int row = 0;
        int col = matrix[0].length - 1;
        while (row < matrix.length && col >= 0) {
            if (target == matrix[row][col]) {
                return true;
            }
            
            if (target < matrix[row][col]) {
                col--;
            } else {
                row++;
            }
        }
        
        return false;
    }
}
```

#### 题5，替换空格

1）首先遍历字符串求出空格个数；在Java中，String属于不可变类型，需要转换成char数组进行处理；

2）对char数组进行扩容，由‘%20’替代‘ ’，实际上是原字符数组长度增加空格数**2，即tail=length+countBlanks**2；

3）对字符数组进行由后向前的遍历处理：标记两个下标length（原字符数组长度）-1（记p）表示原字符数组的末位字符，tail(扩容后字符数组长度)-1（记q）表示扩容后字符数组的末尾字符；如果p指向的字符为空，则需要作替换处理（q前填充‘0’，‘2’，‘%’并向前移动3，p向前移动1），反之p，q均向前移动1，如此下去，直到p与q指向同一个位置，说明空格已全部替换完成。

```java
public String replaceSpace(String s) {
    int length = s.length();
    char[] chars = s.toCharArray();
    
    int countBlanks = 0;
    for (char ch: chars) { 
        if (ch == ' ') { 
            countBlanks++;
        } 
    }
    
    int tail = length + countBlanks * 2;
    chars = Arrays.copyOf(chars, tail);
    while (length != tail) { 
        if (chars[length - 1] != ' ') { 
            chars[tail - 1] = chars[length - 1];
            length--;
            tail--; 
        } else { 
            chars[tail - 1] = '0';
            chars[tail - 2] = '2';
            chars[tail - 3] = '%';
            length--;
            tail -= 3; 
        } 
    }
  
    return new String(chars);
}
```

#### 题6，从尾到头打印链表

解法一：栈思想

遍历链表，同时利用ArrayList结构（add(index,value)方法相当于压栈操作）存储每一个节点的value，然后将ArrayList通过循环遍历赋值给数组。时间复杂度和空间复杂度均为O(n)。

```java
class Solution {
    public int[] reversePrint(ListNode head) {
        List<Integer> arrayList = new ArrayList();
        while (head != null) {
            arrayList.add(0, head.val);
            head = head.next;
        }
        
        int[] array = new int[arrayList.size()];
        int i = 0;
        for (int item: arrayList) {
            array[i++] = item;
        }
        
        return array;
    }
}
```

- 解法二：递归法

```java
class Solution {
    List<Integer> list = new ArrayList();
    public int[] reversePrint(ListNode head) {
        if (head != null && head.next != null) {
            reversePrint(head.next);
        }
        
        if (head != null) {
            list.add(head.val);
        }

        int i = 0;
        int[] array = new int[list.size()];
        for(int item : list) {
            array[i++] = item;
        }
        return array;
    }
}
```

#### 题11，旋转数组的最小数字

```java
/**
 * 面试题11. 旋转数组的最小数字
 * 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
 * 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。
 * 例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。
 *
 * 示例 1：
 * 输入：[3,4,5,1,2]
 * 输出：1
 *
 * 示例 2：
 * 输入：[2,2,2,0,1]
 * 输出：0
 *
 * @author zhangbocheng
 */
public class Solution {
    public int minArray(int[] numbers) {
        if (numbers == null || numbers.length < 1) {
            throw new ArithmeticException("Empty array!");
        }

        int low = 0, high = numbers.length - 1;
        int mid;
        while (low < high) {
            mid = (low + high) / 2;
            if (numbers[mid] > numbers[high]) {
                low = mid + 1;
            } else if (numbers[mid] < numbers[high])  {
                high = mid;
            } else {
                high--;
            }
        }

        return numbers[low];
    }
}
```

#### 题25，合并两个有序链表

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode merge, p, q, s;
        merge = new ListNode(0);
        s = merge;  // 用一个新节点指向一个新链表，关键点
        p = list1;
        q = list2;

        while(p != null && q != null) {
            if (p.val < q.val) {
                s.next = p;
                p = p.next;
            } else {
                s.next = q;
                q = q.next;
            }
            s = s.next;
        }

        s.next = p !=null ? p : q;
        return merge.next;
    }
}
```

#### 题58 - I. 翻转单词顺序

```java
/**
 * 面试题58 - I. 翻转单词顺序
 * 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。
 * 为简单起见，标点符号和普通字母一样处理。
 * 例如输入字符串"I am a student. "，则输出"student. a am I"。
 *
 * 示例 1：
 * 输入: "the sky is blue"
 * 输出: "blue is sky the"
 *
 * 示例 2：
 * 输入: "  hello world!  "
 * 输出: "world! hello"
 * 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
 *
 * 示例 3：
 * 输入: "a good   example"
 * 输出: "example good a"
 * 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
 *
 * @author zhangbocheng
 */
class Solution {
    public String reverseWords(String s) {
        if (s == null || s.length() < 1) {
            return s;
        }
        
        String[] words = s.trim().split(" ");
        StringBuilder str = new StringBuilder();
        for (int i = words.length - 1; i >= 0; i--) {
            if ("".equals(words[i])) {
                continue;
            }

            str.append(words[i]);
            str.append(" ");
        }
        
        return str.toString().trim();
    }
}
```

#### 题58 - II. 左旋转字符串

- 方法一

```java
/**
 * 面试题58 - II. 左旋转字符串
 * 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。
 * 请定义一个函数实现字符串左旋转操作的功能。
 * 比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。
 *
 * 示例 1：
 * 输入: s = "abcdefg", k = 2
 * 输出: "cdefgab"
 *
 * 示例 2：
 * 输入: s = "lrloseumgh", k = 6
 * 输出: "umghlrlose"
 *
 * 限制：
 * 1 <= k < s.length <= 10000
 *
 * @author zhangbocheng
 */
class Solution {
    public String reverseLeftWords(String s, int n) {
        if (s == null || s.length() < 1
                || s.length() < n || n < 1 || s.length() > 10000) {
            return null;
        }

        StringBuilder sb = new StringBuilder();
        sb.append(s.substring(n, s.length()));
        sb.append(s.substring(0, n));
        return sb.toString();
    }
}
```

- 方法二，三步反转法

```java
/**
 * 面试题58 - II. 左旋转字符串
 * 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。
 * 请定义一个函数实现字符串左旋转操作的功能。
 * 比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。
 *
 * 示例 1：
 * 输入: s = "abcdefg", k = 2
 * 输出: "cdefgab"
 *
 * 示例 2：
 * 输入: s = "lrloseumgh", k = 6
 * 输出: "umghlrlose"
 *
 * 限制：
 * 1 <= k < s.length <= 10000
 *
 * @author zhangbocheng
 */
class Solution {
   public String reverseLeftWords(String s, int n) {
        if (s == null || s.length() < 1
                || s.length() < n || n < 1 || s.length() > 10000) {
            return null;
        }

        String s1 = reverseString(s.substring(0, n));
        String s2 = reverseString(s.substring(n, s.length()));
        return reverseString(s1.concat(s2));
    }

    public String reverseString(String s) {
        StringBuilder sb = new StringBuilder();
        sb.append(s).reverse();
        return sb.toString();
    }
}
```

#### 题29，顺时针打印矩阵

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if (matrix == null || matrix.length < 1) {
            return new int[0];
        }

        int start = 0, number = 2, count = 0;
        int rowLength = matrix.length;
        int colLength = matrix[0].length;
        int[] array = new int[rowLength * colLength];
        // 遍历一周，行数和列数均减小2
        while (start * number < rowLength && start * number < colLength) {
            int endX = rowLength - start - 1;
            int endY = colLength - start - 1;
            // top row
            for (int i = start; i <= endY; i++) {
                array[count++] = matrix[start][i];
            }
            // right column
            for (int j = start + 1; j <= endX; j++) {
                array[count++] = matrix[j][endY];
            }
            // bottom column，endX控制单行情况
            for (int k = endY - 1; endX > start && k >= start; k--) {
                array[count++] = matrix[endX][k];
            }
            // left column, endY控制单列情况
            for (int m = endX - 1; endY > start && m > start; m--) {
                array[count++] = matrix[m][start];
            }
            start++;
        }

        return array;
    }
}
```

#### 题64. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

运行结果如下：

![转字符串法]

#### 题64. 求1+2+…+n（☑️）

> 原题链接：https://leetcode-cn.com/problems/qiu-12n-lcof/

**题目描述**

> 求 `1+2+...+n` ，要求不能使用乘除法、`for`、`while`、`if`、`else`、`switch`、`case` 等关键字及条件判断语句（`A?B:C`）。

**思路分析**

> 本题抛开要求限制，算是入门级题目，但是加上条件限制却变成了一道思维拓展题，不涉及任何算法知识。这里给出两种解决方案：
>
> 方法一：递归法，递归需要判断终止条件，除了 `if` 语句，还有 `switch`，逻辑运算符，进而可以突破 `if` 的限制，达到解题目的；
>
> 方法二：等差数列求和公式，$$S_{n}=\frac{(1+n)*n}{2}$$，这里出现了乘除法，现在就需要想方设法找道乘除法的替代方案，除法可以用位运算替代；乘法呢？将分子展开即有 $$n^2 + n$$，平方可以调用库函数 `pow`。

**参考代码**

- 方法一：递归法，其时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public int sumNums(int n) {
        int sum = n;
        boolean flag = n > 0 && (sum += sumNums(n - 1)) > 0;
        return sum;
    }
}
```

运行结果如下：

![递归法](images/leetcode_20200602003011.png)

- 方法二：等差数列公式，其时间复杂度为 $O(1)$ ，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public int sumNums(int n) {
        return ((int)Math.pow(n, 2) + n) >> 1;
    }
}
```

运行结果如下：

![等差数列公式](images/leetcode_20200602113841.png)













