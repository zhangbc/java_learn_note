# 笔试刷题集

## Leetcode题集

#### 9. 回文数（☑️）

> 原题链接：https://leetcode-cn.com/problems/palindrome-number/

**题目描述**

>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**思路分析**

> 由于整数的特殊性，如果为负数，则易知不是回文数（因为整数的末尾不可能出现符号）。
>
> 方法一：此题最容易想到的就是把数字转成字符串 `str`，然后用双指针法(`low`，`high`)进行首尾遍历，当 `str[low] != str[high]` 说明不是回文；否则进行下一轮，`low++，high--` ，直到`low >= high` 循环结束。
>
> 方法二：方法一是常规的字符串解法，没有充分利用本题的整数这一条件，回文数是指整数的前部分（负数除外）和后半部分形成对称，也就是说只要将整数拆成位数相等（如果整数的奇数位去中间位）的两部分并且将后半部分翻转与前半部分相比，如相等则说明是回文数，否则不是。需要处理的问题有：1）整数翻转，定义一个新的整型变量 `reverse`，循环每次取 `x` 的个位数，然后 `reverse = reverse * 10 + x % 10`，同时需要将 `x = x / 10`，这样可以将`x`进行翻转；2）拆分整数`x`为两部分，本题只需要判断前半部分和翻转后的后半分部分是否相等即可，所以循环的终止条件是 `x <= reverse`，当整数 `x` 为偶数位时两数相等；当整数 `x` 为奇数位时 `x < reverse`，因为多出的中间位被添加到 `reverse` 的末尾，所以最终判断是否为回文数的条件应该为 `x == reverse || x == reverse / 10` ；3）注意特殊情况，如果 `x` 的个位数为0，那么易知整数不是回文数，2）中的最终判断条件会判定 `x = 10` 为 `true` ，这是最容易忽略的一点。

**参考代码**

- 方法一：转字符串法，时间复杂度为 $O(n/2)$，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public boolean isPalindrome(int x) {
        String value = String.valueOf(x);
        int low = 0;
        int high = value.length() - 1;
        while (low < high) {
            if (value.charAt(low) != value.charAt(high)) {
                return false;
            }
            
            low++;
            high--;
        }
        
        return true;
    }
}
```

运行结果如下：

![转字符串法](images/leetcode_20200514125544.png)

- 方法二：反转后半部分数字，时间复杂度为 $O(log_{10}n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean isPalindrome(int x) {
        boolean flag = x < 0 || (x % 10 ==0 && x != 0);
        if (flag) {
            return false;
        }

        int reverse = 0;
        while (x > reverse) {
            reverse = reverse * 10 + x % 10;
            x /= 10;
        }

        return x == reverse || x == reverse / 10;
    }
}
```

运行结果如下：

![反转后半部分数字](images/leetcode_20200514121403.png)

#### 10. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

方法二：暴力优化解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

运行结果如下：

![转字符串法]



#### 28. 实现 strStr()（☑️）

> 标题：【Leetcode刷题】字符串模式匹配算法知多少
>
> 原题链接：https://leetcode-cn.com/problems/implement-strstr/

**题目描述**

> 实现 `strStr()` 函数。
>
> 给定一个 `haystack` 字符串和一个 `needle` 字符串，在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
>
> 说明：
>
> > 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
> >
> > 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

**思路分析**

> 方法一/二：此题最先也是最容易想到的是暴力解法，但是实践证明，在 `Java` 提交中通不过，逐一判断超时，增加条件即满足首尾相等在进行判断相等，即可优化解，提交可以通过；
>
> 方法三：通过对暴力解分析，利用 `Java` 字符串截取方法，通过逐一比较子字符串可得；
>
> 方法四：前三种方法实质都是通过逐一比较子字符串求解，其实还有更进一步优化，分析发现其实并不是所有长度为 `needle.length()` 需要比较，可以利用双指针判断，具体做法是：定义两个指针 `p`，`q` 分别指向 `haystack`，`needle`，从首字符开始，如果不相等，则移动 `p`；如果两个指针指向相等，则同时移动下一位，直至 `p` 指向 `needle` 的尾字符，如果仍相等，则说明找到其位置，程序结束；否则需要从不相等的位置开始同时向前回溯（`p` 再次指向 `needle` 的首字符为止）；如此循环即可；
>
> 方法五：`Rabin Karp` 算法，其思路是先生成窗口内子串的哈希码，然后再跟 `needle` 字符串的哈希码做比较。如何在常数时间生成子串的哈希码？ 这里需要涉及到**滚动哈希**：常数时间生成哈希码，利用滑动窗口的特性，每次滑动都有一个元素进，一个出，生成一个长度为 `L` 数组的哈希码，需要 $O(L)$ 时间。算法步骤如下：
>
> > 计算子字符串 `haystack.substring(0, L)` 和 `needle.substring(0, L)` 的哈希值。
> >
> > 从起始位置开始遍历：从第一个字符遍历到第 N - L 个字符；
> >
> > 根据前一个哈希值计算滚动哈希；
> >
> > 如果子字符串哈希值与 `needle` 字符串哈希值相等，返回滑动窗口起始位置。
> >
> > 返回 -1，这时候 `haystack` 字符串中不存在 `needle` 字符串。
>
> 方法六：`BM`（`Boyer-Moore`）算法，其思想是有模式串中不存在的字符，那么肯定不匹配，往后多移动几位，提高效率，遵循**坏字符**规则，**好后缀**规则。
>
> > 1）**坏字符规则**：当文本串中的某个字符跟模式串的某个字符不匹配时，称文本串中的这个失配字符为**坏字符**，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果"坏字符"不包含在模式串之中，则最右出现位置为-1；
> >
> > 2）**好后缀规则**：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。
>
> 本题采用坏字符规则，具体做法是：首先针对模式串 `needle` 构造模式串的数组表（哈希表） `suffix` （本题是字符串默认为基本字符，`ASCII` 码是8位），然后从 `haystack` 的首字符循环遍历长度为 `needle.length()` 的子串， 跳跃为 `skip`， 用 `needle` 从后往前匹配，如果整个模式串匹配成功则 `skip=0` 终止程序，否则 `skip = j - suffix[haystack.charAt(i + j)]`，直到最后一个子串，如果未匹配成功，最后返回 `-1`。
>
> 方法七：`KMP` (`Knuth-Morris-Pratt `) 算法，基本思路如下：
>
> > 假设现在文本串 `S` 匹配到 `i` 位置，模式串 `P` 匹配到 `j` 位置：
> >
> > > 1）如果 `j = -1`，或者当前字符匹配成功（即 `S[i] == P[j]`），都令 `i++`，`j++`，继续匹配下一个字符；
> > >
> > > 2）如果 `j != -1`，且当前字符匹配失败（即 `S[i] != P[j]`），则令 `i` 不变，`j = next[j]`。此举意味着失配时，模式串 `P` 相对于文本串 `S` 向右移动了 `j - next [j]` 位。
> > >
> > > `next` 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如`next [j] = k`，代表 `j` 之前的字符串中有最大长度为 `k` 的相同前缀后缀。
>
> 算法步骤：首先求解模式串 `P` 的 `next` 数组：定义长度为 `P.length()` 的数组 `next`，遍历模式串 `P`，取 `i=-1,j=0`，若 `P.charAt(j)` 与 `P.charAt(i)` 相等，则 `j` 的下一个跳到 `i` 的下一个处，否则退回至 `next[i]`，循环结束即可得`next` 数组；然后同时循环遍历文本串 `S` 和 模式串 `P` ，根据上述思路即可完成。
>
> 方法八：`Sunday`算法，是 `Daniel M.Sunday` 于1990年提出的字符串模式匹配，其核心思想是：在匹配过程中，模式串发现不匹配时，算法能跳过尽可能多的字符以进行下一步的匹配，从而提高了匹配效率。`Sunday` 算法思想跟 `BM` 算法很相似，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符，如果该字符没有在匹配串中出现则直接跳过，即移动步长= 匹配串长度+1；否则，同 `BM` 算法一样其移动步长=匹配串中最右端的该字符到末尾的距离+1。
>
> 算法步骤：定义模式串的哈希表（本题采用数组），循环遍历 `haystack`，每次取长度为 `needle.length()` 的子串与`needle`比较，如果相等则返回对应的下标，程序结束；否则，判断 `haystack.charAt(i + needle.length())` 是否在 `needle` 中：若在则移动步长 `skip` 为1；若不在，则移动步长 `skip` 为 `i + needle.length()`，直到最后一个子串，如果未匹配成功，最后返回 `-1`。
>
> 测试用例组：
>
> > 1）`haystack` = "`hello`", `needle` = "`ll`"
> >
> > 2）`haystack` = "`aaaaa`", `needle` = "`bba`"
> >
> > 3）`haystack` = "`a`", `needle` = "`a`"
> >
> > 4）`haystack` = "`aaa`", `needle` = "`aaaa`"
> >
> > 5）`haystack` = "`mississippi`", `needle` = "`a`" 
> >
> > 6）`haystack` = "`mississippi`", `needle` = "`issi`"

**参考代码**

- ~~方法一：暴力解法，**[提交时，超出时间限制]**，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。~~

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        for (int i = 0; i < haystack.length(); i++) {
            if (haystack.charAt(i) == needle.charAt(0)) {
                boolean result = isSubStr(haystack, needle, i);
                if (result) {
                    return i;
                }
            }
        }
        
        return -1;
    }

    private boolean isSubStr(String haystack, String needle, int i) {
        for (int j = 0; j < needle.length(); j++) {
            if (i == haystack.length()) {
                return false;
            }
            
            if (haystack.charAt(i) != needle.charAt(j)) {
                return false;
            }
            
            i++;
        }
        
        return true;
    }
}
```

运行结果如下：

![暴力法](images/leetcode_20200530142931.png)

- 方法二：暴力优化解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        int len = needle.length();
        for (int i = 0; i < haystack.length(); i++) {
            if (haystack.charAt(i) == needle.charAt(0) 
                    && i + len - 1 < haystack.length()
                    && haystack.charAt(i + len - 1) == needle.charAt(len - 1)) {
                boolean result = isSubStr(haystack, needle, i);
                if (result) {
                    return i;
                }
            }
        }
        
        return -1;
    }

    private boolean isSubStr(String haystack, String needle, int i) {
        for (int j = 0; j < needle.length(); j++) {
            if (i == haystack.length()) {
                return false;
            }

            if (haystack.charAt(i) != needle.charAt(j)) {
                return false;
            }
            
            i++;
        }
        
        return true;
    }
}
```

运行结果如下：

![暴力优化法](images/leetcode_20200530143536.png)

- 方法三：字符串截取+逐一比较子字符串，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。


```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        for (int i = 0; i < haystack.length(); i++) {
            if (i + needle.length() <= haystack.length() 
            && haystack.substring(i, i + needle.length()).equals(needle)) {
                return i;
            }
        }

        return -1;
    }
}
```

运行结果如下：

![字符串截取+逐一比较子字符串](images/leetcode_20200530145406.png)

- 方法四：双指针法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        int p = 0, q, curLen;
        while (p + needle.length() - 1 < haystack.length()) {
            // 不相等，则移动p
            while (p + needle.length() - 1 < haystack.length()
                    && haystack.charAt(p) != needle.charAt(0)) {
                p++;
            }

            q = 0;
            curLen = 0;
            // 两个指针指向相等，则同时移动下一位
            while (p < haystack.length() && q < needle.length()
                    && haystack.charAt(p) == needle.charAt(q)) {
                p++;
                q++;
                curLen++;
            }

            if (curLen == needle.length()) {
                return p - curLen;
            }
            
            // 向前回溯
            p = p - curLen + 1;
        }

        return -1;
    }
}
```

运行结果如下：

![双指针法](images/leetcode_20200530154251.png)

- 方法五：`Rabin Karp` 算法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        if (haystack.length() < needle.length()) {
            return -1;
        }

        // 设置滚动哈希函数的基值--本题取a
        int base = 26;
        long module = (long)Math.pow(2, 31);

        // 计算Hash值
        long hash = 0, refHash = 0;
        for (int i = 0; i < needle.length(); i++) {
            hash = (hash * base + charToInt(haystack, i)) % module;
            refHash = (refHash * base + charToInt(needle, i)) % module;
        }

        // 首部匹配成功
        if (hash == refHash) {
            return 0;
        }

        // 计算最高位
        long bit = 1;
        for (int i = 0; i < needle.length(); i++) {
            bit = (bit * base) % module;
        }
        
        // 遍历并判断查找
        for (int i = 1; i < haystack.length() - needle.length() + 1; i++) {
            hash = (hash * base - charToInt( haystack, i - 1) * bit
                    + charToInt(haystack, i + needle.length() - 1)) % module;
            if (hash == refHash) {
                return i;
            }
        }

        return -1;
    }

    private int charToInt(String string, int i) {
        return string.charAt(i) - 'a';
    }
}
```

运行结果如下：

![RabinKarp](images/leetcode_20200530191937.png)

- 方法六：`BM` 算法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        // 构建模式串的数组表（哈希表）
        int[] suffix = generateSuffix(needle);

        int skip;
        for (int i = 0; i <= haystack.length() - needle.length(); i += skip) {
            skip = 0;
            for (int j = needle.length() - 1; j >= 0; j--) {
                if (needle.charAt(j) != haystack.charAt(i + j)) {
                    // 计算跳跃步数
                    skip = j - suffix[haystack.charAt(i + j)];
                    skip = skip < 1 ? 1 : skip;
                    break;
                }
            }

            if (skip == 0) {
                return i;
            }
        }
        return -1;
    }

    private int[] generateSuffix(String needle) {
        int max = 128;
        int[] suffix = new int[max];
        for (int i = 0; i < max; i++) {
            suffix[i] = -1;
        }

        for (int i = 0; i < needle.length(); i++) {
            suffix[needle.charAt(i)] = i;
        }
        
        return suffix;
    }
}
```

运行结果如下：

![BM算法](images/leetcode_20200530212634.png)

- 方法七：`KMP` 算法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        int[] next = getNext(needle);
        int i = 0, j = 0;
        while (i < haystack.length() && j < needle.length()) {
            if (j == -1 || haystack.charAt(i) == needle.charAt(j)) {
                i++;
                j++;
            } else {
                j = next[j];
            }
        }

        return j == needle.length() ? i - j : -1;
    }

    private int[] getNext(String pattern) {
        int[] next = new int[pattern.length()];
        next[0] = -1;
        int i = -1, j = 0;
        while (j < pattern.length() - 1) {
            if (i == -1 || pattern.charAt(j) == pattern.charAt(i)) {
                // 若相等，则j的下一个跳到i的下一个处
                next[++j] = ++i;
                if (pattern.charAt(j) == pattern.charAt(i)) {
                    //若继续相等，则再往前跳
                    next[j] = next[i];
                }
            } else {
                //不相等则移回到i处
                i = next[i];
            }
        }

        return next;
    }
}
```

运行结果如下：

![KMP算法](images/leetcode_20200530232301.png)

- 方法八：`Sunday`算法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        // 构建模式串的数组表（哈希表）
        int[] suffix = generateSuffix(needle);

        int skip;
        for (int i = 0; i <= haystack.length() - needle.length(); i += skip) {
            if (needle.equals(haystack.substring(i, i + needle.length()))) {
                return i;
            } else {
                skip = i + needle.length() < haystack.length()
                        && suffix[haystack.charAt(i + needle.length())] == -1
                        ? i + needle.length() : 1;
            }
        }
        return -1;
    }

    private int[] generateSuffix(String needle) {
        int max = 128;
        int[] suffix = new int[max];
        for (int i = 0; i < max; i++) {
            suffix[i] = -1;
        }

        for (int i = 0; i < needle.length(); i++) {
            suffix[needle.charAt(i)] = i;
        }

        return suffix;
    }
}
```

运行结果如下：

![Sunday算法](images/leetcode_20200531003038.png)

**参考资料**

> [官方题解](https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode/)
>
> [Rabin-Karp算法](https://blog.csdn.net/seacowtech/article/details/79256299)
>
> [子串查找算法-Rabin-Karp](https://www.jianshu.com/p/68cbe955103e)
>
> [面试算法之字符串匹配算法，Rabin-Karp算法详解](https://blog.csdn.net/tyler_download/article/details/52457108?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)
>
> [从头到尾彻底理解KMP（2014年8月22日版）](https://blog.csdn.net/v_july_v/article/details/7041827)
>
> [字符串匹配算法（BM）](https://blog.csdn.net/qq_21201267/article/details/92799488)
>
> [KMP算法和BM算法的java简单实现](https://www.jianshu.com/p/dad121ffc46f)

#### 35. 搜索插入位置（☑️）

> 原题链接：https://leetcode-cn.com/problems/search-insert-position/

**题目描述**

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 你可以假设数组中无重复元素。

**思路分析**

> 分析题意，可以理解为给一个已排好序的数组“插入”一个数，求解其插入位置。这里给出两种解法。
>
> 方法一：常规解法，逐一遍历每一个元素并与目标值比较，如果目标值大于前一个数而小于等与后一个数，那么应返回后一个数的位置，即为插入位置；如果目标值小于第一个元素应返回0；如果目标值大于最后一个元素应返回数组的长度，即为插入位置；
>
> 方法二：二分查找法，进一步探究方法一，其实质就是查找，那么可以优化查找算法，从而可以应用二分法查找，降低时间复杂度。

**参考代码**

- 方法一：常规解法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        if (nums == null || nums.length < 1) {
            return 0;
        }

        for (int i = 0; i < nums.length; i++) {
            if (target <= nums[i]) {
                return i;
            }
        }

        return nums.length;
    }
}
```

运行结果如下：

![常规解法](images/leetcode_20200601215744.png)

- 方法二：二分查找法，其时间复杂度为 $O(log{n})$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        if (nums == null || nums.length < 1) {
            return 0;
        }

        int low = 0, high = nums.length - 1, mid;
        while (low <= high) {
            mid = (low + high) / 2;
            if (target < nums[mid]) {
                high = mid - 1;
            } else if (target == nums[mid]) {
                return mid;
            } else {
                low = mid + 1;
            }
        }
        
        return low;
    }
}
```

运行结果如下：

![二分查找法](images/leetcode_20200601215004.png)

#### 46. 全排列

> 原题链接：https://leetcode-cn.com/problems/permutations/

**题目描述**

> 给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

**思路分析**

> 方法一：（递归法）从集合中依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理，从而得到所有元素的全排列。
> 
> 方法二：（字典序排序） 给定两个偏序集 `A` 和 `B`, (`a`,`b`) 和 (`a′`,`b′`) 属于笛卡尔集 `A × B`，则 **字典序** 定义为(`a`,`b`) `≤` (`a′`,`b′`) 当且仅当 `a < a′` 或 (`a = a′` 且 `b ≤ b′`)。 所以给定两个字符串，逐个字符比较，那么先出现较小字符的那个串字典顺序小，如果字符一直相等，较短的串字典顺序小。例如： `abc` < `abcd` < `abde` < `afab`。
> 需要这样的一个算法，使得：
>
>> - 起点： 字典序最小的排列，1-`n` ，例如 12345；
>> - 终点： 字典序最大的排列， `n`-1， 例如 54321；
>> - 过程： 从当前排列生成字典序刚好比它大的下一个排列。

> `next_permutation` 算法
>
> > - 定义：**升序**：相邻两个位置 $a_i {\lt} a_{i +1}$，$a_i$ 称作该升序的首位；
> > - 步骤（二找、一交换、一翻转）：
> >   1）找到排列中最后（最右）一个升序的首位位置 $i$， $x =a_i$；
> >   2）找到排列中第 `i` 位右边最后一个比 $a_i$ 大的位置 $j$，$y = a_j$；
> >   3）交换 $x$，$y$；
> >   4）把第 $(i + 1)$ 位到最后的部分翻转。
>
> 方法三：回溯法
>
> ```java
> result = []
> def backtrack(路径, 选择列表):
>     if 满足结束条件:
>         result.add(路径)
>         return
>     
>     for 选择 in 选择列表:
>         做选择
>         backtrack(路径, 选择列表)
>         撤销选择
> ```
>
> 方法四：深度优先遍历（`DFS`）


**参考代码**

- 方法一：递归法，时间复杂度为 $O(n!)$，空间复杂度为 $O(n)$。

```java
import java.util.ArrayList;
import java.util.List;

public class Solution {

    List<List<Integer>> array = new ArrayList<>(16);

    public List<List<Integer>> permute(int[] nums) {
        if (nums == null || nums.length < 1) {
            return array;
        }

        calcAllPermute(nums, 0, nums.length - 1);
        return array;
    }

    private void calcAllPermute(int[] nums, int from, int to) {
        if (to < 0) {
            return;
        }
        
        if (from == to) {
            List<Integer> items = new ArrayList<>(16);
            for (int i = 0; i <= to; i++) {
                items.add(nums[i]);
            }
            array.add(items);
        } else {
            for (int i = from; i <= to; i++) {
                swap(nums, i, from);
                calcAllPermute(nums, from + 1, to);
                swap(nums, i, from);
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

运行结果如下：

![递归法](images/leetcode_20200905164743.png)

- 方法二：字典序排序，时间复杂度为 $O(n!)$，空间复杂度为 $O(n)$。

```java
import java.util.List;

class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> array = new ArrayList<>(16);
        if (nums == null || nums.length < 1) {
            return array;
        }

        Arrays.sort(nums);

        while (true) {
            List<Integer> temp = new ArrayList<>(16);
            for (int item: nums) {
                temp.add(item);
            }
            array.add(temp);
            
            if (!calcAllPermutationDic(nums)) {
                break;
            }
        }

        return array;
    }

    private boolean calcAllPermutationDic(int[] nums) {
        int i, index = 2;
        // ① 找到排列中最后(最右)一个升序的首位位置i，x=a_i
        for(i = nums.length - index; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                break;
            }
        }

        // 已经找到所有排序
        if(i < 0) {
            return false;
        }

        int k;
        // ② 找到排列中第i个右边最后一个比a_i大的位置j，y=a_j
        for(k = nums.length - 1; k > i; k--) {
            if (nums[k] > nums[i]) {
                break;
            }
        }

        // ③ 交换x，y
        nums[i] += nums[k];
        nums[k] = nums[i] - nums[k];
        nums[i] -= nums[k];

        // ④ 把第(i+1)位到最后的部分翻转
        for (int j = i + 1, m = nums.length - 1; j < m; j++, m--) {
            nums[j] += nums[m];
            nums[m] = nums[j] - nums[m];
            nums[j] -= nums[m];
        }
        return true;
    }
}
```

运行结果如下：

![字典排序](images/leetcode_20200905170916.png)

- 方法三：回溯法，时间复杂度为 $O(n!)$，空间复杂度为 $O(n)$。

```java
import java.util.List;

/**
 * def backtrack(路径, 选择列表):
 *      if 满足结束条件:
 *          result.add(路径)
 *          return
 *
 *     for 选择 in 选择列表:
 *         做选择
 *         backtrack(路径, 选择列表)
 *         撤销选择
 *
 *  @author zhangbocheng
 */
class Solution {
    private List<List<Integer>> array = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        if (nums == null || nums.length < 1) {
            return array;
        }

        Stack<Integer> track = new Stack<>();
        backTrack(nums, track);
        return array;
    }

    private void backTrack(int[] nums, Stack<Integer> track) {
        if (track.size() == nums.length) {
            array.add(new ArrayList<>(track));
            return;
        }

        for (int i: nums) {
            if (track.contains(i)) {
                continue;
            }

            track.push(i);
            backTrack(nums, track);
            track.pop();
        }
    }
}
```

运行结果如下：

![回溯法](images/leetcode_20200905173700.png)

- 方法四：`DFS` 法，时间复杂度为 $O(nlogn)$，空间复杂度为 $O(n)$。

```java
import java.util.List;

class Solution {
    private List<List<Integer>> array = new ArrayList<>(16);
    public List<List<Integer>> permute(int[] nums) {
        if (nums == null || nums.length < 1) {
            return array;
        }

        Stack<Integer> depth = new Stack<>();
        boolean[] visited = new boolean[nums.length];
        dfs(nums, 0, depth, visited);
        return array;
    }

    private void dfs(int[] nums, int depth, Stack<Integer> path, boolean[] visited) {
        if (depth == nums.length) {
            array.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (visited[i]) {
                continue;
            }

            path.add(nums[i]);
            visited[i] = true;
            dfs(nums, depth + 1, path, visited);
            path.pop();
            visited[i] = false;
        }
    }
}
```

运行结果如下：

![DFS法](images/leetcode_20200905175100.png)

#### 60. 第k个排列

> 原题链接：https://leetcode-cn.com/problems/permutation-sequence/

**题目描述**

> 给出集合 $[1,2,3,\dots,n]$ ，其所有元素共有 $n!$ 种排列。
>
> 按大小顺序列出所有排列情况，并一一标记，当 $n = 3$ 时, 所有排列如下：
>
> ```
> "123"
> "132"
> "213"
> "231"
> "312"
> "321"
> ```
>
> 给定 `n` 和 `k`，返回第 `k` 个排列。
>
> ==说明：==
>
> > 给定 `n` 的范围是 [1, 9]。
> > 给定 `k` 的范围是[1, n!]。

**思路分析**

> 方法一：字典序排序，参考题46中的字典序排序思路，不同之处在于求第 `k` 个序列，增加一个计数器即可。

**参考代码**

方法一：字典序排序，时间复杂度为 $O(n!)$，空间复杂度为 $O(n)$。

```java
import java.util.ArrayList;
import java.util.List;

public class Solution {
    public String getPermutation(int n, int k) {
        int[] nums = new int[n];
        for (int i = 1; i <= n; i++) {
            nums[i-1] = i;
        }

        while (true) {
            List<String> temp = new ArrayList<>(16);
            for (int num: nums) {
                temp.add(String.valueOf(num));
            }

            k--;
            if (k == 0) {
                return String.join("", temp);
            }

            if (!next(nums)) {
                break;
            }
        }

        return null;
    }

    private boolean next(int[] nums) {
        int i, index = 2;
        for (i = nums.length - index; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                break;
            }
        }

        if (i < 0) {
            return false;
        }

        int k;
        for (k = nums.length - 1; k > i; k--) {
            if (nums[k] > nums[i]) {
                break;
            }
        }

        nums[i] += nums[k];
        nums[k] = nums[i] - nums[k];
        nums[i] -= nums[k];

        for (int j = i + 1, m = nums.length - 1; j < m; j++, m--) {
            nums[j] += nums[m];
            nums[m] = nums[j] - nums[m];
            nums[j] -= nums[m];
        }

        return true;
    }
}
```

运行结果如下：

![转字符串法](images/leetcode_20200905200300.png)

#### 107. 二叉树的层次遍历 II

> 原题链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/

**题目描述**

> 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
>
> 例如：
> 给定二叉树 [3,9,20,null,null,15,7]，
>
>     3
>     / \
>     9  20
>     /  \
>     15   7
> 返回其自底向上的层次遍历为：
>
> ```
> [
>   [15,7],
>   [9,20],
>   [3]
> ]
> ```

**思路分析**

> 这是一道常规的 `BFS` 变式题，只需要在遍历时记下每一层的节点数，在出队时作为局部整体数组输出到最终结果中。

**参考代码**

- 方法一：BFS法，时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
import java.util.*;

class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> arrays = new ArrayList<>();
        if (root == null) {
            return arrays;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int levelCount;
        while (!queue.isEmpty()) {
            levelCount = queue.size();
            List<Integer> lever = new ArrayList<>();
            for (int i = 0; i < levelCount; i++) {
                TreeNode node = queue.poll();
                lever.add(node.val);
                
                if (node.left != null) {
                    queue.offer(node.left);
                }
                
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            
            arrays.add(0, lever);
        }
        
        return arrays;
    }
}
```

运行结果如下：

![BFS法](images/leetcode_20200906092602.png)

#### 283. 移动零 

> 原题链接：https://leetcode-cn.com/problems/move-zeroes/

**题目描述**

> 给定一个数组 `nums`，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> ==说明：==
>
> > 必须在原数组上操作，不能拷贝额外的数组。
> > 尽量减少操作次数。

**思路分析**

> 减少操作次数即要求最小的移动代价，每个需要移动的元素仅仅移动一次即可。换个思路看，既然是把 0 移动到末尾，那只需要留下非零元素，然后在数组末尾部分用0填充即可。

**参考代码**

- 方法一：最小移动法，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        if (nums == null || nums.length < 1) {
            return;
        }
        
        int i = 0, j = 0;
        for (; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[j++] = nums[i];
            }
        }
        
        while (j < nums.length) {
            nums[j++] = 0;
        }
    }
}
```

运行结果如下：

![移动零](images/leetcode_20200905120343.png)

#### 392. 判断子序列

> 原题链接：https://leetcode-cn.com/problems/is-subsequence/

**题目描述**

> 给定字符串 `s` 和 `t` ，判断 `s` 是否为 `t` 的子序列。
>
> 你可以认为 `s` 和 `t` 中仅包含英文小写字母。字符串 `t` 可能会很长（长度 ~= 500,000），而 `s` 是个短字符串（长度 <=100）。
>
> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”`ace`”是”`abcde`"的一个子序列，而”`aec`"不是）。
>
> ==后续挑战 :==
>
> > 如果有大量输入的 $S$，称作 $S_1, S_2, \dots , S_k$ 其中 $k {\ge}10亿$，你需要依次检查它们是否为 $T$ 的子序列。在这种情况下，你会怎样改变代码？

**思路分析**

> 方法一：（双指针法）初始化两个指针 `i` 和 `j`，分别指向 `s` 和 `t` 的初始位置。每次贪心地匹配，匹配成功则 `i` 和 `j` 同时右移，匹配 `s` 的下一个位置，匹配失败则 `j` 右移，`i` 不变，尝试用 `t` 的下一个字符匹配 `s`。
>
> 此题为2021年美团数据库开发笔试题的原型题。

**参考代码**

方法一：双指针法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        // i为s的下标，j为t的下标
        int i = 0, j = 0;
        while (i < s.length() && j < t.length()) {
            if (s.charAt(i) == t.charAt(j)) {
                i++;
                j++;
            } else {
                j++;
            }
        }

        return i == s.length();
    }
}
```

运行结果如下：

![双指针法](images/leetcode_20200920115828.png)

#### 404. 左叶子之和

> 原题链接：https://leetcode-cn.com/problems/sum-of-left-leaves/

**题目描述**

> 计算给定二叉树的所有左叶子之和。
>
> 示例：
>
> ```
>     3
>    / \
>   9  20
>     /  \
>    15   7
> ```
> 
> 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24。
>

**思路分析**

> 此题属于简单题，基本的二叉树遍历算法（`BFS` 和 `DFS`），对叶子结点的判断条件考查，没有陷阱。解法只给出 `BFS` 解法。

**参考代码**

- 方法一：`BFS`法，时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。 

```java
import java.util.LinkedList;
import java.util.Queue;

class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        int sum = 0;
        if (root == null) {
            return sum;
        }

        Queue<TreeNode> nodes = new LinkedList<>();
        nodes.offer(root);
        while (!nodes.isEmpty()) {
            TreeNode node = nodes.poll();
            if (node.left != null && isLeafNode(node.left)) {
                sum += node.left.val;
            }

            if (node.left != null && !isLeafNode(node.left)) {
                nodes.offer(node.left);
            }

            if (node.right != null && !isLeafNode(node.right)) {
                nodes.offer(node.right);
            }
        }

        return sum;
    }

    private boolean isLeafNode(TreeNode node) {
        return node.left == null && node.right == null;
    }
}
```

运行结果如下：

![BFS法](images/leetcode_20200919214927.png)

#### 453. 最小移动次数使数组元素相等

> 原题链接：https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/

**题目描述**

> 给定一个长度为 $n$ 的 **非空** 整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 $n - 1$ 个元素增加 1。
>
> 示例：
>
> > 输入：[1,2,3]
> >
> > 输出：3
> >
> > ==解释==
> > 只需要3次移动（注意每次移动会增加两个元素的值）：
> > [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]

**思路分析**

> 方法一：（数学法）分析题目，通过移动增加使得所有元素最终相等，换而言之，就是求最小移动次数使得数组中最小元素和最大元素达到相等。每次固定其中最大的一个元素，其他元素移动一次，这样保证移动次数最小，假定最大值固定，那么就可以得出一个结论：移动次数就是数组中每个元素与最小元素的差的总和。**误区**：移动次数为数组中最大元素与每个元素的差的总和。测试用例：[1, 1, 2147483647]
>
> 方法二：（动态规划）考虑有序数组 $a$。假设，直到 $i-1$ 位置的元素都已经相等，只需要考虑 $i$ 位的元素，将差值 $diff=a[i]-a[i-1]$ 加到总移动次数上，使得第 $i$ 位也相等，$moves=moves+diff$。
>
> 但当继续这一步时，$a[i]$ 之后的元素也会被增加 $diff$，亦即 $a[j]=a[j]+diff$，其中 $j>i$。
>
> 但当实现本方法时，不需要对这样的 $a[j]$ 进行增加。相反把 $moves$ 的数量增加到当前元素（$a[i]$）中，$a'[i]=a[i]+moves$。
>
> 简而言之，我们对数列进行排序，一直更新 $moves$ 以使得直到当前的元素相等，而不改变除了当前元素之外的元素。在整个数组扫描完毕后，$moves$ 即为答案。
>

**参考代码**

- 方法一：数学法，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。 

```java
class Solution {
    public int minMoves(int[] nums) {
        int min = nums[0];
        for (int item: nums) {
            if (min > item) {
                min = item;
            }
        }

        int sum = 0;
        for (int item: nums) {
            sum += item - min;
        }

        return sum;
    }
}
```

运行结果：

![数学法](images/leetcode_20200904102621.png)

方法二：动态规划，时间复杂度为 $O(nlogn)$，空间复杂度为 $O(1)$。

```java
public class Solution {
    public int minMoves(int[] nums) {
        int moves = 0, diff;
        Arrays.sort(nums);

        for (int i = 1; i < nums.length; i++) {
            diff = moves + nums[i] - nums[i - 1];
            nums[i] += moves;
            moves += diff;
        }

        return moves;
    }
}
```

![动态规划](images/leetcode_20200904112608.png)

#### 523. 连续的子数组和

> 原题链接：https://leetcode-cn.com/problems/continuous-subarray-sum/

**题目描述**

> 给定一个包含非负数的数组和一个目标整数 $k$，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为2，且总和为 $k$ 的倍数，即总和为 $n*k$，其中 $n$ 也是一个整数。
>

**思路分析**

> 方法一：（暴力法）每次移动的时候，需要从起始位置逐个检测去掉之前元素的和 `sum` 能否被目标整数 `k` 整除。注意子数组元素个数最小为2；
>
> 方法二：（`HaspMap` + 前缀和法）遍历数组，记录到当前位置为止的 `sum` （`sum = sum % k`）。一旦找到新的 `sum` 的值（即在 `HashMap` 中没有这个值），就往 `HashMap` 中插入一条记录 `sum`。假设第 `i` 个位置的 `sum` 的值为 `rem`。如果以 `i` 为左端点的任何子数组的和是 `k` 的倍数，比如这个位置为 `j` ，那么 `HashMap` 中第 `j` 个元素保存的值为 `(rem + n * k) % k`，其中 `n` 是某个大于 0 的整数。结果发现：发现 `( rem + n ∗ k) % k = rem` ，也就是跟第 `i` 个元素保存到 `HashMap` 中的值相同，即得结论：无论何时，只要 相同的 `sum` 的值再次被放入 `HashMap` 中，代表着有两个索引 `i` 和 `j`，它们之间元素的和是 `k` 的整数倍；
>
> 方法三：（动态规划）分别算出长度为 $2,3,{\dots},m$ 的子数组的和，判断是否为 $k$ 的倍数即可。具体方法是：将 `nums` 的数据拷贝到 `dp` 中，计算长度为2的子数组和时，$dp[j] = dp[j] + nums[j+1]$；这里的 $dp[j]$ 就是 $nums[j]$ ；计算长度为3的子数组和时，$dp[j] = dp[j] + nums[j+2]$；这里的 $dp[j]$ 是更新过的 $dp[j]$ ，一个 $dp[j]$ 相当于 $nums[j]+nums[j+1]$ … 这样当计算长度为 $p$ 的子数组大小时，就可以利用已经计算过的长度为 $p-1$ 的子数组进行更新，就可以对原来的三重循环进行优化，变为二重循环。
>
> 测试用例：
>
> > 1）目标值为 0
> >
> > 2）[0,1,0,1,0,1] 0
> >
> > 3）[0,0,1,2,0] 0
>
> 这是云从科技2021校招 `Java` 开发工程师笔试题，当时采用方法一只 `AC` 0.6，主要原因有两点：1）没有考虑目标整数为0的情况；2）忘记暴力子数组和每次应归零。

**参考代码**

- 方法一：暴力法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int sum = nums[0], pre, s;
        for (int i = 1; i < nums.length; i++) {
            sum += nums[i];
            if ((k == sum) || (k != 0 && sum % k == 0)) {
                return true;
            }
            pre = 0;
            s = sum;
            while (i - pre > 1) {
                s -= nums[pre];
                pre++;
                if ((k == s) || (k != 0 && s % k == 0)) {
                    return true;
                }
            }
        }

        return false;
    }
}
```

运行结果如下：

![暴力法](images/leetcode_20200919235415.png)

- 方法二：`HaspMap` + 前缀和法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        if (nums == null || nums.length < 1) {
            return false;
        }

        Map<Integer, Integer> map = new HashMap<>(16);
        int sum = 0;
        map.put(0,-1);
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (k != 0) {
                sum = sum % k;
            }

            if (map.containsKey(sum)) {
                if (i - map.get(sum) > 1) {
                    return true;
                }
            } else {
                map.put(sum, i);
            }
        }

        return false;
    }
}
```

运行结果如下：

![HaspMap+前缀和法](images/leetcode_20200920094134.png)

方法三：动态规划，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        if (nums == null || nums.length < 1) {
            return false;
        }

        int[] dp = new int[nums.length];
        System.arraycopy(nums, 0, dp, 0, nums.length);

        int count = 2;
        while (count <= nums.length) {
            for (int i = 0; i + count - 1 < dp.length; i++) {
                dp[i] += nums[i + count - 1];
                if (k == 0 && dp[i] == 0) {
                    return true;
                }

                if (k != 0 && dp[i] % k == 0) {
                    return true;
                }
            }
            count++;
        }

        return false;
    }
}
```

![动态规划](images/leetcode_20200920163907.png)

#### 560. 和为K的子数组（☑️）

> 原题链接：https://leetcode-cn.com/problems/subarray-sum-equals-k/

**题目描述**

> 给定一个整数数组和一个整数 $k$，你需要找到该数组中和为 $k$ 的连续的子数组的个数。
>

**思路分析**

> 方法一：此题最容易想到的暴力解法即枚举法，从数组的第一个元素开始，累加求和 `sum` 直到数组的最后一个元素结束（数组是无序，需要求的是连续的子数组，千万不能满足找到了第一个子数组就跳出循环，这是很容易忽略的地方），用一个整型变量`counts` 记录 `sum == k` 的个数，然后对第 `2～n` 做同样的处理，最后把每次循环后得到的 `counts` 累加便是本题的答案。注意此方法解题需要注意的几个特例（需要处理的细节问题）：
>
> > 1）子数组可能只含一个元素，如 `[1,1,3] 3`；
> >
> > 2）子数组可能就是整个数组，如 `[28,54,7,-70,22,65,-6] 100`；
> >
> > 3）以某个元素开始的满足条件的子数组可能不止一个，如 `[0,0,0,0,0,0,0,0,0,0] 0`。
>
> 方法二：前缀和+哈希优化法，此方法最不容易想到。对方法一进行优化分析，定义一个新的整型数组 `pre` ，用 `pre[i]` 记录数组的前 `i` 项和，容易得到递推公式：
> $$
> pre[i] = pre[i-1]+nums[i]
> $$
> 那么在 `[j ... i]` 中，和为 `k` 为的条件可表示为：
> $$
> pre[i]-pre[j-1]==k
> $$
> 所以考虑以 `i` 结尾的和为 `k` 的连续子数组个数时只要统计有多少个前缀和为 `pre[i]-k` 的 `pre[j]` 即可。为了简化 `pre` 操作可以用 `hashMap` 存储，定义为 `map`，`key` 为和值 `pre[i]`，`value` 为对应 `pre[i]` 出现的次数，从左往右边更新 `map` 边计算答案，那么以 `i` 结尾的答案 `map[pre[i]−k]` 即可在 $O(1)$ 时间内得到，最终答案即为所有下标结尾的和为 `k` 的子数组个数之和。
>

**参考代码**

- 方法一：暴力枚举法，时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0;
        if (nums == null || nums.length < 1) {
            return count;
        }

        for (int i = 0; i < nums.length; i++) {
            count += getSums(nums, i, k);
        }
        
        return count;
    }

    private int getSums(int[] nums, int i, int k) {
        int counts = 0;
        int sum = nums[i];
        if (sum == k) {
            counts++;
        }

        while (i < nums.length - 1) {
            sum += nums[++i];
            if (sum == k) {
                counts++;
            }
        }

        return counts;
    }
}
```

运行结果如下：

![暴力枚举法](images/leetcode_20200515012859.png)

- 方法二：前缀和+哈希优化，时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0, pre = 0;
        if (nums == null || nums.length < 1) {
            return count;
        }

        HashMap<Integer, Integer> map = new HashMap<>(16);
        map.put(0,1);
        for (int i = 0; i < nums.length; i++) {
            pre += nums[i];
            if (map.containsKey(pre - k)) {
                count += map.get(pre - k);
            }

            map.put(pre, map.getOrDefault(pre, 0) + 1);
        }

        return count;
    }
}
```

运行结果如下：

![前缀和哈希优化](images/leetcode_20200515102934.png)

#### 680. 验证回文字符串 Ⅱ（☑️）

> 原题链接：https://leetcode-cn.com/problems/valid-palindrome-ii/

**题目描述**

> 给定一个非空字符串 `s`，**最多**删除一个字符。判断是否能成为回文字符串。
>
> **注意：** 字符串只包含从 `a-z` 的小写字母。字符串的最大长度是50000。

**思路分析**

> 这题是回文判断的一个变式题，主要还是考查对双指针的理解。用 `low` 和 `high` 分别指向字符串 `s` 的首位和末尾，如果二者相等，则执行 `low++` ，`high--` ；如果不相等，则需要分两种情况：
>
> > 1）第 `low + 1` 位与第 `high` 位相等，依次循环判断，如果为回文字符串，则返回 `true` ，否则返回 `false` ，记为 `usedLeft`；
> >
> > 2）第 `low` 位与第 `high - 1` 位相等，依次循环判断，如果为回文字符串，则返回 `true` ，否则返回 `false` ，记为 `usedRight`。
>
> 最后，综合不等情况判断，只要不等情况1）和2）中有一个符合回文字符串，那么都应该返回 `true`，即判断条件应为  `usedLeft||usedRight`	；跳出循环如果还没返回值，说明是标准的回文串，应返回 `true`。
>
> 做题过程中，对不等判断很容易忽视情况1）和2）是**或**的关系判断， 即忽略判断两边都可以的情况（**贪心算法思想**）。如测试实例：`"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga"`。

**参考代码**

- 双指针法，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean validPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return false;
        }

        int low = 0, high = s.length() - 1;
        while (low < high) {
            if (s.charAt(low) == s.charAt(high)) {
                low++;
                high--;
                continue;
            }

            int left = low + 1, right = high - 1;
            boolean usedLeft = isPalindrome(s, left, high);
            boolean usedRight = isPalindrome(s, low, right);
            return usedLeft || usedRight;
        }

        return true;
    }

    private boolean isPalindrome(String s, int low, int high) {
        while (low < high) {
            if (s.charAt(low) != s.charAt(high)) {
                return false;
            }
            
            low++;
            high--;
        }
        
        return true;
    }
}
```

运行结果如下：

![双指针法](images/leetcode_20200519104743.png)

#### 876. 链表的中间结点

- 方法一：常规思路法

```java
/**
 * 876. 链表的中间结点
 * 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。
 * 如果有两个中间结点，则返回第二个中间结点。
 *
 * 示例 1：
 * 输入：[1,2,3,4,5]
 * 输出：此列表中的结点 3 (序列化形式：[3,4,5]
 * 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
 * 注意，我们返回了一个 ListNode 类型的对象 ans，这样：
 * ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
 *
 * 示例 2：
 * 输入：[1,2,3,4,5,6]
 * 输出：此列表中的结点 4 (序列化形式：[4,5,6])
 * 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
 * 提示：
 * 给定链表的结点数介于 1 和 100 之间。
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/3/23 10:38
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode p = head;
        int count = 0;
        while (p != null) {
            count++;
            p = p.next;
        }

        int mid = count / 2 + 1;
        count = 1;
        p = head;
        while (count < mid) {
            count++;
            p = p.next;
        }
        return p;
    }
}
```

- 方法二：数组法（官方解）

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */

/**
 * 876. 链表的中间结点
 * 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。
 * 如果有两个中间结点，则返回第二个中间结点。
 *
 * 示例 1：
 * 输入：[1,2,3,4,5]
 * 输出：此列表中的结点 3 (序列化形式：[3,4,5]
 * 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
 * 注意，我们返回了一个 ListNode 类型的对象 ans，这样：
 * ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
 *
 * 示例 2：
 * 输入：[1,2,3,4,5,6]
 * 输出：此列表中的结点 4 (序列化形式：[4,5,6])
 * 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
 * 提示：
 * 给定链表的结点数介于 1 和 100 之间。
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/3/23 10:38
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        final int COUNT = 100;
        ListNode[] arrayNodes = new ListNode[COUNT];
        int count = 0;
        while (head != null) {
            arrayNodes[count++] = head;
            head = head.next;
        }
        return arrayNodes[count / 2];
    }
}
```

- 方法三：快慢指针法

```java

```





#### 1431. 拥有最多糖果的孩子（☑️）

> 原题链接：https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/

**题目描述**

> 给你一个数组 `candies` 和一个整数 `extraCandies` ，其中 `candies[i]` 代表第 `i` 个孩子拥有的糖果数目。
>
> 对每一个孩子，检查是否存在一种方案，将额外的 `extraCandies` 个糖果分配给孩子们之后，此孩子有**最多**的糖果。注意，允许有多个孩子同时拥有**最多**的糖果数目。
>
> 示例 1：
>
> > 输入：`candies = [2,3,5,1,3], extraCandies = 3`
> > 输出：`[true,true,true,false,true]` 
> > **==解释==**：
> > 孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。
> > 孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
> > 孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。
> > 孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。
> > 孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
>
> 示例 2：
>
> > 输入：`candies = [4,2,1,1,2], extraCandies = 1`
> > 输出：`[true,false,false,false,false]`
> > **==解释==**：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。

**思路分析**

> 对题目理解不透彻的话，强烈建议看示例中解释，很好地帮助我们审了题意，即本题要求是：针对组内每一个小朋友手中糖果`candies[i]` ，若把额外的糖果 `extraCandies` 分配给他，判断能否达到或者超过组内糖果的最大值。因而，解答应分两步走：1）求出组内最大值 `max`；2）针对组内每一个元素加上 `extraCandies` 判断能否达到或超过最大值，若能记为 `true`，否则记为 `false`，将结果保存为一个数组并返回。

**参考代码**

- 常规解法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        List<Boolean> result = new ArrayList<>();
        if (candies == null || candies.length < 1) {
            return result;
        }

        int max = candies[0];
        for (int value: candies) {
            max = Math.max(value, max);
        }

        for (int value: candies) {
            result.add(value + extraCandies >= max);
        }
        
        return result;
    }
}
```

运行结果如下：

![常规解法](images/leetcode_20200601100250.png)

## 企业面试真题

#### 百度2021届校园招聘秋招笔试题

- 李华的礼物

> 题目描述：
>
> > 李华顺利地到达了巴黎，他的好友 `Peter` 带他开启了他的巴黎之旅。途中，李华遇到了许多心动的纪念品想要带回家，但是他又不想自己太累，而且他买纪念品也有相应的预算 `k`，现给出他心动的纪念品清单：共有 `n` 件，其中每件都各有其价格 `price`，重量 `weight`，心动值 `v` (其中心动值为1~5之间的数值)，需要注意的是：在心动值不同的情况下，李华会优先选择心动值大的纪念品；若心动值相同，李华会优先选择比较便宜的纪念品，具体见样例。同时给出李华在保证不累的情况下，最多能拿的物品重量 `m`。在不超过预算并且保证不累的情况下，李华最多可以带几件纪念品回家？
>
> 输入描述：
>
> > 单组输入。
> > 第1行三个正整数，分别为：纪念品件数 `n`，最多能拿的物品重量 `m`，预算 `k`。（`n<1e5，m<100，k<10000，k` 的单位为元，`m` 的重量为 `kg`）
> >
> > 第2行到第 `n+1` 行，分别为每件物品的价格 `price`，重量 `weight`，心动值 `v`。（`price<10000，weight<100`，`v` 为1~5之间的整数，`price` 的单位为元，`weight` 的重量为 `kg`）
>
> 输出描述：
>
> > 在不超过预算并且保证不累的情况下，李华最多可以带回家的纪念品件数。
>
> 样例输入：
>
> > 3 10 1000
> > 100 5 3
> > 50 3 2
> > 300 3 3
>
> 样例输出：
>
> > 2
>
> 解释：
>
> > 李华会优先选择心动值较大的礼物1，3，且总重量和预算都没超过，所以输出为2。

思路分析

> 其实想明白了挺简单的，当时感觉真脑子短路了。优先按心动值降序，然后心动值相同按照价格升序，考察的核心就是多关键字排序问题。

代码如下：

```java
package com.exam;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

/**
 * 样例输入：
 * 3 10 1000
 * 100 5 3
 * 50 3 2
 * 300 3 3
 *
 * 样例输出：
 * 2
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/9/4 11:50
 */
public class BaiduGift {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String[] row = sc.nextLine().split(" ");
        // 礼物行数
        int n = Integer.parseInt(row[0]);
        // 可承受的总重量
        int m = Integer.parseInt(row[1]);
        // 总预算
        int k = Integer.parseInt(row[2]);

        // 构造礼物矩阵
        List<Gift> giftArray = new ArrayList<>(16);
        while (n > 0) {
            String[] items = sc.nextLine().split(" ");
            Gift gift = new Gift();
            gift.setPrice(Integer.parseInt(items[0]));
            gift.setWeight(Integer.parseInt(items[1]));
            gift.setV(Integer.parseInt(items[2]));
            giftArray.add(gift);
            n--;
        }

        System.out.println(getGiftNumber(giftArray, m, k));
    }

    private static int getGiftNumber(List<Gift> giftArray, int m, int k) {
       List<Gift> gifts = giftArray.stream()
               .sorted(Comparator.comparing(Gift::getV).reversed()
                       .thenComparing(Gift::getPrice)).collect(Collectors.toList());
       int count = 0;
       for (Gift gift: gifts) {
            m -= gift.getWeight();
            k -= gift.getPrice();
            if (m < 0 || k < 0) {
                break;
            }
            count++;
            // 验证
            System.out.printf("%d\t%d\t%d\n", gift.getPrice(), gift.getWeight(), gift.getV());
        }

       return count;
    }

    static class Gift {
        /**
         * 价格
         */
        private int price;
        /**
         * 重量
         */
        private int weight;
        /**
         * 心动值
         */
        private int v;

        public int getPrice() {
            return price;
        }

        public void setPrice(int price) {
            this.price = price;
        }

        public int getWeight() {
            return weight;
        }

        public void setWeight(int weight) {
            this.weight = weight;
        }

        public int getV() {
            return v;
        }

        public void setV(int v) {
            this.v = v;
        }
    }
}
```

- 最小计分

> 题目描述：
>
> > 小度最近在研究一个棋盘游戏，游戏规则如下：
> >
> > 一个 $N*N$ 的棋盘，每个格子里面填写有1、2、3、4这四个数字中的某一个。最开始时在第1行第1列（左上角）放置一个棋子。每次棋子可以移动至上、下、左、右四个格子中的某一个，每次只能移动一格（允许重复移动到某一个格子），在任何时刻都不允许将棋子移出棋盘。在移动时需要进行计分。如果初始格子中的数字为 $X$，目标格子中的数字为 $Y$，则本次移动计分为 $|X-Y|$（取 $X-Y$ 的绝对值），即两个格子中的数字之差。 
> >
> > 现在需要把棋子移动到第 $N$ 行第 $N$ 列（右下角），请问能够获得的最小计分为多少？
>
> 输入描述：
>
> > 单组输入。
> > 第1行为 $N$。（$1{\le}N{\le}100$）
> > 接下来N行为一个二维数组，表示棋盘上每一个格子及其对应的数字（正整数）。
>
> 输出描述：
>
> > 输出一个正整数，表示最小计分。
>
> 样例输入：
>
> > 3
> > 1 2 4
> > 1 3 1
> > 1 2 1
>
> 样例输出：
>
> > 2

#### 美团笔试2021届数据库开发笔试题

- 六位数

> 时间限制： 3000 `MS`
>
> 内存限制： 589824 `KB`
>
> 题目描述：
>
> > 小团想要编写一个程序，希望可以统计在 `M` 和 `N` 之间（`M<N`，且包含 `M` 和 `N`）有多少个六位数 `ABCDEF` 满足以下要求：
> >  (1) `ABCDEF` 这六个数字均不相同，即 `A、B、C、D、E` 和 `F` 表示六个不同的数字。
> >  (2) `AB+CD=EF`。即将这个六位数拆成三个两位数，使得第1个和第2个两位数的和等于第3个两位数。
> > （注意：`AB`、`CD` 和 `EF` 都必须是正常的两位数，因此 `A`、`C` 和 `E` 都不能等于0。）
>
> 输入描述
>
> > 单组输入。
> >
> > 输入两个六位正整数 `M` 和 `N`（`M<N`），两者之间用空格隔开。
>
> 输出描述
>
> > 输出在 `M` 到 `N` 之间（包含 `M` 和 `N`）满足要求的六位数的个数。
>
> 样例输入
>
> > 100000 110000
>
> 样例输出
>
> > 0

 本题已 `AC`，代码如下：

```java
package com.exam;

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Test01 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] numbers = scanner.nextLine().split(" ");
        int m = 0, n = 0;
        try {
            m = Integer.parseInt(numbers[0]);
            n = Integer.parseInt(numbers[1]);
        } catch (Exception e) {
            System.out.println("Input error!");
            System.exit(0);
        }

        System.out.println(getBitCount(m, n));
    }

    private static int getBitCount(int m, int n) {
        int count = 0;
        if (m > n) {
            return count;
        }

        for (int i = m; i <= n; i++) {
            if (String.valueOf(i).length() < 6) {
                continue;
            }

            if (String.valueOf(i).length() > 6) {
                break;
            }

            if (isNumber(i)) {
                count += 1;
            }
        }

        return count;
    }

    private static boolean isNumber(int i) {
        String strNumber = String.valueOf(i);

        Map<Character, Integer> map = new HashMap<>(16);
        int number1 = 0;
        int number2 = 0;
        int number3 = 0;
        for (int j = 0; j < strNumber.length(); j++) {
            if (map.containsKey(strNumber.charAt(j))) {
                return false;
            } else {
                map.put(strNumber.charAt(j), j);
            }

            if(j == 1) {
                number1 = i / 10000;
            }

            if (j == 3) {
                number2 = (i / 100) % 100;
            }

            if (j == 5) {
                number3 = i % 100;
            }
        }

        return number1 > 0 && number1 + number2 == number3;
    }
}
```

- 小美的新游戏

> 时间限制： 3000 `MS`
> 内存限制： 589824 `KB`
>
> 题目描述：
>
> > 小美和小团合作开发了一款新游戏！他们相信这款游戏一定可以大火。
> >
> > 游戏规则是这样的，现在有一个方格地图，你控制一个机器人位于初始位置(`x, y`)，然后你可以向上下左右的地块移动。其中一些地块上会有得分点，经过这些点可以获得分数。当然，路上还会有一些陷阱点，如果想要通过陷阱点，就需要付出一定的分数来清除这个陷阱点。注意陷阱点付出分数清除后就会变成普通的地块。即反复经过陷阱点只需付出一次代价。同样的，得分点也只能获得一次分数。
> >
> > 小美想到了一个策划案来让这个游戏变得难一些。小美把地图和机器人的初始位置给了小团，并且告诉了小团他操控机器人的行进路线。小美想试试小团能不能算出来他的最终得分。
> >
> > 小团完美地完成了这个任务。现在，小美和小团想找一些测试人员看看这款游戏的难度如何。他们找到了你，希望你帮他们测试一下这个游戏。而你能否挑战成功呢？
> >
> >  注意分数允许为负，初始分数为0。
>
> 输入描述
>
> > 第一行四个数字 `N，M，P，Q`，表示这张地图是 `N` 行 `M` 列的，得分点的得分是 `P`，陷阱点清除的代价是 `Q`。
> >
> > 接下来 `N` 行，每行 `M` 个字符，表示这张地图。其中，字符 `S` 表示初始机器人位置。字符 `#` 表示墙壁，字符 `O` 代表得分点。字符 `X` 代表陷阱点。字符 `+` 代表普通的地块。
> >
> > 接下来一行一个连续的字符串表示机器人的移动路线，只由大写字母 `WASD` 构成，`W` 向上，`A` 向左，`S` 向下，`D` 向右。机器人可以上下左右移动。不能超出地图边界。也不能走到墙壁之上。试图走出边界和走到墙壁的行动会停留在原来的位置不动。
>
> 输出描述
>
> > 一个整数，表示小团的机器人最终获得了多少分。
>
> 样例输入
>
> >  ```
> >  6 6 20 10
> >  S#++O#
> >  OXX#X#
> >  ++++++
> >  ###XX#
> >  ++#O#+
> >  OXO++X
> >  SSDDDDDAWWSSSAWSSSADDD
> >  ```
> 
> 样例输出
> > 40
> 
> ==提示==
> > 其中地图大小对全体数据都有 $1{\le}N,M{\le}500$
> > 对于得分点分数和陷阱点分数 $P$ 和 $Q$ 对全体数据都有 $1{\le}P,Q{\le}1000$
> > 接下来是机器人行进路线，有行进路线长度小于等于100000


- 小美找朋友

> 时间限制：3000 `MS`
> 内存限制：589824 `KB`
>
> 题目描述：
>
> > 小美将自己朋友的名字写在了一块，惊讶地发现她写出的那个字符串 `S` 有一个惊人的性质：一个人是小美的朋友当且仅当她/他的名字是那个字符串的子序列。现在小团想根据那个字符串判断一个人是不是小美的朋友。
> >
> > **子序列**：一个字符串 `A` 是另外一个字符串 `B` 的子序列，当且仅当可以通过在 `B` 中删除若干个字符（也可能一个都不删），其他字符保留原来顺序，使得形成的新字符串 `B’` 与 `A` 串相等。例如，`ABC` 是 `AABDDC` 的子序列，而 `ACB` 不是 `AABDDC` 的子序列。
>
> 输入描述
>
> > 第一行两个正整数 `n，m` 分别表示小美朋友字符串 `S` 的长度，以及小团想了解是不是小美朋友的那个人的名字字符串 `T` 的长度。
> >
> > 第二行长度为 `n` 且仅包含小写字母的字符串 `S`
> >
> > 第三行长度为 `m` 且仅包含小写字母的字符串 `T`
> >
> > `max(n,m)<=200000`
>
> 输出描述
>
> > 如果小团想了解的那个人不是小美的朋友(即，`T` 不是 `S` 的子序列)，输出一行”`No`”,否则输出一行”`Yes`”，并在第二行将 `T` 对应到 `S` 中的位置之和输出出来(从1开始编号)，由于可能有多种对应方式，请输出最小的位置之和。请参见样例解释获取更详细说明。
>
> 样例输入
>
> >  6 3
> >  aabddc
> >  abc
>
>  样例输出
>
> >  Yes
> >  10
>
> ==提示==
>
> 输入样例2
>
> > 6 3
> > aabddc
> > acb
>
> 输出样例2
>
> > No
>
> ==样例解释==
>
> > 这两组样例均为题目中提到过的对子序列的说明。
> >
> > 对于样例1
> >
> > > `S=aabddc T=abc`，`T`中 `a` 可以与 `S` 中第1个字符 `a` 对应起来，`b` 可以与 `S` 中第3个字符 `b` 对应起来，`c` 可以与 `S` 中第6个字符 `c` 对应起来，这样一来就找到了一个 `S` 中的子序列(仅保留第1、3、6个字符形成的子序列)，使其与 `T` 相等。这种情况下，位置之和为 1+3+6=10；还有一种方案，是 `S` 仅保留第2、3、6个字符形成的子序列 `abc`，仍然满足与 `T` 相等的条件。但是位置之和为 2+3+6=11，并不是位置之和最小的，因而输出第一种对应方案的位置之和：10。
> >
> > 对于样例2
> >
> > > 可以保留 `S` 中的第1、3、6个字符，形成子序列 `abc`，但与 `T` 串 `acb` 不相等，因为 `b、c` 位置并不对应。可以证明，没有任何一种取 `S` 子序列的方式，可以使得取出的子序列和 `T` 相等，因而输出 `No`。


本题同源题：[392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)，已 `AC` 0.64，代码如下：
```java
package com.exam;

import java.util.Scanner;

public class Test03 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] strNumber = scanner.nextLine().split(" ");
        int m = 0, n = 0;
        try {
            n = Integer.parseInt(strNumber[0]);
            m = Integer.parseInt(strNumber[1]);
        } catch (Exception e) {
            System.out.println("Input error!");
            System.exit(0);
        }

        String s = scanner.nextLine();
        String t = scanner.nextLine();
        boolean flag = s.length() != n || t.length() != m || Math.max(s.length(), t.length()) > 200000;
        if(flag) {
            System.out.println("Input error.");
            System.exit(1);
        }
        // 检查小写字母
        for (int i = 0; i < s.length(); i++) {
            if (!(Character.isLetter(s.charAt(i)) && Character.isLowerCase(s.charAt(i)))) {
                System.out.println("Input error.");
                System.exit(1);
            }
        }

        for (int i = 0; i < t.length(); i++) {
            if (!(Character.isLetter(t.charAt(i)) && Character.isLowerCase(t.charAt(i)))) {
                System.out.println("Input error.");
                System.exit(1);
            }
        }

        int sum = getSubString(s, t);
        if (sum > -1) {
            System.out.println("Yes");
            System.out.println(sum);
        } else {
            System.out.println("No");
        }
    }

    private static int getSubString(String s, String t) {
        // sum 位序之和，i为s的下标，j为t的下标
        int sum = 0, i = 0, j = 0;
        while (i < s.length() && j < t.length()) {
            if (s.charAt(i) == t.charAt(j)) {
                sum += (i + 1);
                i++;
                j++;
            } else {
                i++;
            }
        }

        return j == t.length() ? sum : -1;
    }
}
```
- 小美的美丽树

> 时间限制： 3000 `MS`
> 内存限制： 589824 `KB`
>
> 题目描述：
>
> > 小美在观察一棵美丽的无根树。
> >
> > 小团问小美：“小美，我考考你，如果我选一个点为根，你能不能找出子树大小不超过 `K` 的前提下，子树内最大值和最小值差最大的子树的根是哪个点？多个点的话你给我编号最小的那个点就行了。”
> >
> > 小美思索一番，说这个问题难不倒他。
>
> 输入描述
>
> > 第一行两个正整数 `N` 和 `K`，表示全树有 `N` 个节点，要求子树大小不超过 `K`。
> >
> > 第二行是 `N` 个正整数空格分隔，表示每个点的点权。以点编号从1到 `N` 的顺序给出点权。
> >
> > 接下来 `N-1` 行每行两个正整数表示哪两个点之间有边相连。
> >
> > 最后一行一个正整数 `root` 表示小团所选的根节点编号为 `root`。
> >
> > $N{\le}1e5$，各点上的权值有 $1{\le}点权{\le}1e9$，对于 $K$ 有 $1{\le}K{\le}N$。
>
> 输出描述
>
> > 一行，一个正整数，含义如问题描述，输出在子树大小不超过 `K` 的前提下，子树内最大值和最小值差最大的子树的根的编号。
>
> 样例输入
>
> > 5 2
> > 1 3 2 4 5
> > 1 2
> > 2 3
> > 3 4
> > 4 5
> > 3
>
>  样例输出
>
> > 2

- 矩阵游戏

> 时间限制： 3000 `MS`
> 内存限制： 589824 `KB`
>
> 题目描述：
>
> > 小美有一个2×2的矩阵，矩阵左上角、右上角、左下角、右下角的数字分别为 `0、A、B、C`。
> >
> > 小美觉得该矩阵不够大，她按如下方法扩展该矩阵：
> >
> > 将2×2的矩阵扩展为4×4的矩阵，4×4的矩阵被分为左上角、右上角、左下角、右下角这4个2×2的矩阵，其中左上角为原2×2的矩阵，右上角为原2×2的矩阵每个位置上的数加上 `A`，左下角为原2×2的矩阵每个位置上的数加上 `B`，右下角为原2×2的矩阵每个位置上的数加上 `C`；
> >
> > 将4×4的矩阵扩展为8×8的矩阵，8×8的矩阵被分为左上角、右上角、左下角、右下角这4个4×4的矩阵，其中左上角为原4×4的矩阵，右上角为原4×4的矩阵每个位置上的数加上 `A`，左下角为原4×4的矩阵每个位置上的数加上 `B`，右下角为原4×4的矩阵每个位置上的数加上 `C`；
> >
> > ……
> >
> > 经过不断扩展，小美可以得到一个无穷大的矩阵。小美打算用该矩阵和小团玩游戏，即对小团进行 `N` 次提问，每次给出正整数 `X、Y`，并问小团矩阵上第 `X` 行第 `Y` 列上的数是多少，由于该数可能很大，只要求小团回答该数除以 `10^9` 后的余数。
>
>   输入描述
>
> > 第一行输入四个由空格隔开的整数 `A、B、C` 和 `N`（$0{\le}A,B,C<10^{9}、1{\le}N{\le}10^5$）。
> >
> > 接下来 `N` 行，每行输入两个由空格隔开的整数 `X` 和 `Y`（$1{\le}X,Y{\le}10^9$）。
>
> 输出描述
>
> > 输出 `N` 行，每行输出一个整数，第 `i` 行输出第 `i` 次提问的答案，即矩阵对应位置上的数除以 $10^9$ 后的余数。
>
> 样例输入
>
> > 1 2 3 5
> >  3 3
> >  5 6
> >  6 1
> >  8 3
> >  8 8
>
>  样例输出
>
> > 3
> > 4
> > 4
> > 7
> > 9
>
> ==提示==
>
> > 样例解释：
> > 扩展后的矩阵前8行和前8列如下：
> >   0 1 1 2 1 2 2 3
> >   2 3 3 4 3 4 4 5
> >   2 3 3 4 3 4 4 5
> >   4 5 5 6 5 6 6 7
> >   2 3 3 4 3 4 4 5
> >   4 5 5 6 5 6 6 7
> >   4 5 5 6 5 6 6 7
> >   6 7 7 8 7 8 8 9

#### 字节跳动2021届研发大数据笔试题

- 兔子生兔子，兔子何其多

>时间限制：`C/C++` 1秒，其他语言2秒
>
>空间限制：`C/C++` 32768 `K`，其他语言 65536 `K`
>
>`64bit IO Format:%lld`
>
>题目描述：
>
>> 如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第 `n` 个月能繁殖成多少对兔子？（举例第1个月生1对兔子，第2个月是2对兔子）
>
>输入描述：
>
>> 第一行输入 `N` ，表示第 `N` 个月
>
>输出描述：
>
>> 数字 `R`，表示兔子的对数
>
>输入：
>
>> 5
>
>输出：
>
>> 8

- 字符串最短循环子串

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 26144 `K`，其他语言 524288 `K`
>
> `64bit IO Format:%lld`
>
> 题目描述：
>
> > 输入一个字符串，判断其是否完全循环，若是循环的，输出最短的循环子串，否则输出自身。
> >
> > 如输入 `abababab`，输出 `ab`；输入 `ab` 则输出自身 `ab`。
>
> 输入描述：
>
> > 字符串，如 `abababab`
>
> 输出描述：
>
> > 最短循环子串，如对应例子输出 `ab`
>
> 输入：
>
> > `abababab`
>
> 输出：
>
> > `ab`
>
> ==说明：==
>
> > 输入若是 `ab` ，它不是一个循环串，故输出自身 `ab`
>
> ==备注：==
>
> > 1. `abababab` 以 `ab` 为最小串循环，故输出 `ab`；
> > 2. `abcabcab` 这种不是完全循环，故输出自身 `abcabcab` ；
> > 3. 输入字符串长度不超过 $10^8$。

- 火车站选址

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 26144 `K`，其他语言 524288 `K`
>
> `64bit IO Format:%lld`
>
> 题目描述：
>
> > `A` 市规划新建一个火车站方便市民出行。这里的道路十分规整，市民从位置 $(x_1,y_1)$ 到位置 $(x_2,y_2)$ 的路程为 $|x_1-x_2|+|y_1-y_2|$，经过前期考察，初步选定了 `M` 个可以建造火车站的位置。为了尽可能节省市民到火车站的时间，市长希望新建的火车站离每位市民的总路程尽可能小。
> >
> > 请帮市长选出最合适新建火车站的位置。
>
> 输入描述：
>
> > 第一行有两个整数 `N`，`M` ，分别表示市民的人数和可以建设火车站的位置
> >
> > 后面的 `N`，每行2个整数 $x_i,y_i$ 表示第 $i$ 位市民的居住位置在 $(x_i,y_i)$
> >
> > 后面的 `M`，每行2个整数 $p_i,q_i$ 表示第 $i$ 个火车站候选位置在 $(p_i,q_i)$
> >
> > $1{\le}N,M{\le}100000$
> >
> > $-10000000{\le}x_i,y_i,p_i,q_i{\le}10000000$
> >
> > 其中 50% 的数据，$-100{\le}x_i,y_i,p_i,q_i{\le}100$
>
> 输出描述：
>
> > 两个整数 $p_i,q_i$ 表示最合适新建火车站的位置，若有多个答案，输出原始数据中第一个出现的。
>
> 输入：
>
> > 4 3
> >
> > -1 -1
> >
> > -1 1
> >
> > 1 -1
> >
> > 1 1
> >
> > 3 2
> >
> > 1 0
> >
> > 0 0
>
> 输出：
>
> > 1 0
>
> ==说明：==
>
> > （3，2）距离所有市民总路程为20，（1，0）和（0，0）距离所有市民总路程为8；（1，0）出现在输入数据中的顺序较早，故输出（1，0）。

## 剑指offer 

应聘者需要具备的素质：

> 1）基础知识扎实全面，包括编程语言，数据结构，算法等；
>
> 2）能写出正确的，完整的，鲁棒性的高质量代码；
>
> 3）能思路清晰地分析、解决复杂问题；
>
> 4）能从时间、空间复杂度两个方面优化算法效率；
>
> 5）具备优秀的沟通能力，学习能力，发散思维能力等。

#### 题3，数组中重复的数字（☑️）

> 原题链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof

**题目描述**

> 在一个长度为 $n$ 的数组 $nums$ 里的所有数字都在 $0$ ~ $n-1$ 的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。

**思路分析**

> 通过阅读提干，不难发现，题目要求是从已知数组中找到重复元素即可。这里列出三种解题思路仅作参考：
>
> > 1）最容易想到的算法自然是先排序后通过依次遍历并与后一个元素相比较找出第一个重复元素即可，易想到但是算法代价大不可取，最优时间复杂度为 $O(nlogn)$ ；
> >
> > 2）利用数据结构--`hash`结构，依次遍历数组中每一个元素，同时将元素放入`hash`中，在放入前先做判断：如果在`hash`存在则说明找到重复元素，否则放入`hash`中，直到遍历完所有元素为止，其时间复杂度为 $O(n)$ ，空间复杂度为 $O(n)$ ；
> >
> > 3）充分利用已知条件“数组里的所有数字都在 $0$ ~ $n-1$ 的范围内”，通过交换元素位置比较可以发现是否有重复元素，为本题最优解，其时间复杂度为 $O(n)$ ：
> >
> > > （1）原地改动数组，空间复杂度为 $O(1)$ ；
> > >
> > > （2）定义新数组，空间复杂度为 $O(n)$ 。

**参考代码**

- 方法一：复制数组，时间复杂度为 $O(n)$ ，空间复杂度为 $O(n)$ 。

````java
class Solution {
    public int findRepeatNumber(int[] nums) {
        int[] arr = new int[nums.length];
        for(int i = 0; i < nums.length; i++) {
            arr[nums[i]]++;
            if (arr[nums[i]] > 1 ) {
                return nums[i];
            }
        }

        return -1;
    }
}
````

运行结果如下：

![复制数组](images/leetcode_20200508234733.png)

- 方法二：原地修改数组，时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != i) {
                if (nums[nums[i]] == nums[i]) {
                    return nums[i];
                }
                
                int temp = nums[nums[i]];
                nums[nums[i]] = nums[i];
                nums[i] = temp;
            }
        }

        return -1;
    }
}
```

运行结果如下：

![原地修改数组](images/leetcode_20200508234657.png)

#### 题4，二维数组中的查找

> 原题链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/

**题目描述：**

> 在一个 $n * m$ 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**思路分析：**

> 方法一：暴力解，双循环遍历二维数组，其时间复杂为 $O(n^2)$ ；
>
> 方法二：题目已明确数组按行按列的递增规律，

**参考代码：**

- 方法一：暴力解，其时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if (matrix.length < 1) {
            return false;
        }

        int row = 0;
        int col = matrix[0].length - 1;
        while (row < matrix.length && col >= 0) {
            if (target == matrix[row][col]) {
                return true;
            }
            
            if (target < matrix[row][col]) {
                col--;
            } else {
                row++;
            }
        }
        
        return false;
    }
}
```

#### 题5，替换空格

1）首先遍历字符串求出空格个数；在Java中，String属于不可变类型，需要转换成char数组进行处理；

2）对char数组进行扩容，由‘%20’替代‘ ’，实际上是原字符数组长度增加空格数**2，即tail=length+countBlanks**2；

3）对字符数组进行由后向前的遍历处理：标记两个下标length（原字符数组长度）-1（记p）表示原字符数组的末位字符，tail(扩容后字符数组长度)-1（记q）表示扩容后字符数组的末尾字符；如果p指向的字符为空，则需要作替换处理（q前填充‘0’，‘2’，‘%’并向前移动3，p向前移动1），反之p，q均向前移动1，如此下去，直到p与q指向同一个位置，说明空格已全部替换完成。

```java
public String replaceSpace(String s) {
    int length = s.length();
    char[] chars = s.toCharArray();
    
    int countBlanks = 0;
    for (char ch: chars) { 
        if (ch == ' ') { 
            countBlanks++;
        } 
    }
    
    int tail = length + countBlanks * 2;
    chars = Arrays.copyOf(chars, tail);
    while (length != tail) { 
        if (chars[length - 1] != ' ') { 
            chars[tail - 1] = chars[length - 1];
            length--;
            tail--; 
        } else { 
            chars[tail - 1] = '0';
            chars[tail - 2] = '2';
            chars[tail - 3] = '%';
            length--;
            tail -= 3; 
        } 
    }
  
    return new String(chars);
}
```

#### 题6，从尾到头打印链表

解法一：栈思想

遍历链表，同时利用ArrayList结构（add(index,value)方法相当于压栈操作）存储每一个节点的value，然后将ArrayList通过循环遍历赋值给数组。时间复杂度和空间复杂度均为O(n)。

```java
class Solution {
    public int[] reversePrint(ListNode head) {
        List<Integer> arrayList = new ArrayList();
        while (head != null) {
            arrayList.add(0, head.val);
            head = head.next;
        }
        
        int[] array = new int[arrayList.size()];
        int i = 0;
        for (int item: arrayList) {
            array[i++] = item;
        }
        
        return array;
    }
}
```

- 解法二：递归法

```java
class Solution {
    List<Integer> list = new ArrayList();
    public int[] reversePrint(ListNode head) {
        if (head != null && head.next != null) {
            reversePrint(head.next);
        }
        
        if (head != null) {
            list.add(head.val);
        }

        int i = 0;
        int[] array = new int[list.size()];
        for(int item : list) {
            array[i++] = item;
        }
        return array;
    }
}
```

#### 题11，旋转数组的最小数字

```java
/**
 * 面试题11. 旋转数组的最小数字
 * 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
 * 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。
 * 例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。
 *
 * 示例 1：
 * 输入：[3,4,5,1,2]
 * 输出：1
 *
 * 示例 2：
 * 输入：[2,2,2,0,1]
 * 输出：0
 *
 * @author zhangbocheng
 */
public class Solution {
    public int minArray(int[] numbers) {
        if (numbers == null || numbers.length < 1) {
            throw new ArithmeticException("Empty array!");
        }

        int low = 0, high = numbers.length - 1;
        int mid;
        while (low < high) {
            mid = (low + high) / 2;
            if (numbers[mid] > numbers[high]) {
                low = mid + 1;
            } else if (numbers[mid] < numbers[high])  {
                high = mid;
            } else {
                high--;
            }
        }

        return numbers[low];
    }
}
```

#### 题25，合并两个有序链表

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode merge, p, q, s;
        merge = new ListNode(0);
        s = merge;  // 用一个新节点指向一个新链表，关键点
        p = list1;
        q = list2;

        while(p != null && q != null) {
            if (p.val < q.val) {
                s.next = p;
                p = p.next;
            } else {
                s.next = q;
                q = q.next;
            }
            s = s.next;
        }

        s.next = p !=null ? p : q;
        return merge.next;
    }
}
```

#### 题58 - I. 翻转单词顺序

```java
/**
 * 面试题58 - I. 翻转单词顺序
 * 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。
 * 为简单起见，标点符号和普通字母一样处理。
 * 例如输入字符串"I am a student. "，则输出"student. a am I"。
 *
 * 示例 1：
 * 输入: "the sky is blue"
 * 输出: "blue is sky the"
 *
 * 示例 2：
 * 输入: "  hello world!  "
 * 输出: "world! hello"
 * 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
 *
 * 示例 3：
 * 输入: "a good   example"
 * 输出: "example good a"
 * 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
 *
 * @author zhangbocheng
 */
class Solution {
    public String reverseWords(String s) {
        if (s == null || s.length() < 1) {
            return s;
        }
        
        String[] words = s.trim().split(" ");
        StringBuilder str = new StringBuilder();
        for (int i = words.length - 1; i >= 0; i--) {
            if ("".equals(words[i])) {
                continue;
            }

            str.append(words[i]);
            str.append(" ");
        }
        
        return str.toString().trim();
    }
}
```

#### 题58 - II. 左旋转字符串

- 方法一

```java
/**
 * 面试题58 - II. 左旋转字符串
 * 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。
 * 请定义一个函数实现字符串左旋转操作的功能。
 * 比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。
 *
 * 示例 1：
 * 输入: s = "abcdefg", k = 2
 * 输出: "cdefgab"
 *
 * 示例 2：
 * 输入: s = "lrloseumgh", k = 6
 * 输出: "umghlrlose"
 *
 * 限制：
 * 1 <= k < s.length <= 10000
 *
 * @author zhangbocheng
 */
class Solution {
    public String reverseLeftWords(String s, int n) {
        if (s == null || s.length() < 1
                || s.length() < n || n < 1 || s.length() > 10000) {
            return null;
        }

        StringBuilder sb = new StringBuilder();
        sb.append(s.substring(n, s.length()));
        sb.append(s.substring(0, n));
        return sb.toString();
    }
}
```

- 方法二，三步反转法

```java
/**
 * 面试题58 - II. 左旋转字符串
 * 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。
 * 请定义一个函数实现字符串左旋转操作的功能。
 * 比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。
 *
 * 示例 1：
 * 输入: s = "abcdefg", k = 2
 * 输出: "cdefgab"
 *
 * 示例 2：
 * 输入: s = "lrloseumgh", k = 6
 * 输出: "umghlrlose"
 *
 * 限制：
 * 1 <= k < s.length <= 10000
 *
 * @author zhangbocheng
 */
class Solution {
   public String reverseLeftWords(String s, int n) {
        if (s == null || s.length() < 1
                || s.length() < n || n < 1 || s.length() > 10000) {
            return null;
        }

        String s1 = reverseString(s.substring(0, n));
        String s2 = reverseString(s.substring(n, s.length()));
        return reverseString(s1.concat(s2));
    }

    public String reverseString(String s) {
        StringBuilder sb = new StringBuilder();
        sb.append(s).reverse();
        return sb.toString();
    }
}
```

#### 题29，顺时针打印矩阵

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if (matrix == null || matrix.length < 1) {
            return new int[0];
        }

        int start = 0, number = 2, count = 0;
        int rowLength = matrix.length;
        int colLength = matrix[0].length;
        int[] array = new int[rowLength * colLength];
        // 遍历一周，行数和列数均减小2
        while (start * number < rowLength && start * number < colLength) {
            int endX = rowLength - start - 1;
            int endY = colLength - start - 1;
            // top row
            for (int i = start; i <= endY; i++) {
                array[count++] = matrix[start][i];
            }
            // right column
            for (int j = start + 1; j <= endX; j++) {
                array[count++] = matrix[j][endY];
            }
            // bottom column，endX控制单行情况
            for (int k = endY - 1; endX > start && k >= start; k--) {
                array[count++] = matrix[endX][k];
            }
            // left column, endY控制单列情况
            for (int m = endX - 1; endY > start && m > start; m--) {
                array[count++] = matrix[m][start];
            }
            start++;
        }

        return array;
    }
}
```

#### 题64. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

运行结果如下：

![转字符串法]

#### 题64. 求1+2+…+n（☑️）

> 原题链接：https://leetcode-cn.com/problems/qiu-12n-lcof/

**题目描述**

> 求 `1+2+...+n` ，要求不能使用乘除法、`for`、`while`、`if`、`else`、`switch`、`case` 等关键字及条件判断语句（`A?B:C`）。

**思路分析**

> 本题抛开要求限制，算是入门级题目，但是加上条件限制却变成了一道思维拓展题，不涉及任何算法知识。这里给出两种解决方案：
>
> 方法一：递归法，递归需要判断终止条件，除了 `if` 语句，还有 `switch`，逻辑运算符，进而可以突破 `if` 的限制，达到解题目的；
>
> 方法二：等差数列求和公式，$$S_{n}=\frac{(1+n)*n}{2}$$，这里出现了乘除法，现在就需要想方设法找道乘除法的替代方案，除法可以用位运算替代；乘法呢？将分子展开即有 $$n^2 + n$$，平方可以调用库函数 `pow`。

**参考代码**

- 方法一：递归法，其时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public int sumNums(int n) {
        int sum = n;
        boolean flag = n > 0 && (sum += sumNums(n - 1)) > 0;
        return sum;
    }
}
```

运行结果如下：

![递归法](images/leetcode_20200602003011.png)

- 方法二：等差数列公式，其时间复杂度为 $O(1)$ ，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public int sumNums(int n) {
        return ((int)Math.pow(n, 2) + n) >> 1;
    }
}
```

运行结果如下：

![等差数列公式](images/leetcode_20200602113841.png)













