# 笔试刷题集

## Leetcode题

#### 0. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

方法一：暴力优化解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

运行结果如下：

![]()

#### 1. 两数之和 

> 原题链接：https://leetcode-cn.com/problems/two-sum/

**题目描述**

> 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
>

**思路分析**

> 方法一：（暴力法）两次嵌套循环 $i,j$，如果满足 $nums[i] + nums[j] = target$ ，立即返回即可；
>
> 方法二：（哈希表）方法一的时间复杂度偏高，如果把已遍历的元素用哈希字典存储起来，然后每次遍历时只需要在字典中查找存在否，如果不存在继续遍历，否则立即返回。

**参考代码**

方法一：暴力解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

```java
public class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] array = new int[2];
        for (int i = 0; i < nums.length - 1; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    array[0] = i;
                    array[1] = j;
                    return array;
                }
            }
        }
        return array;
    }
}
```

运行结果如下：

![暴力解法](images/leetcode_20201003153834.png)

方法二：哈希法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] array = new int[2];
        Map<Integer, Integer> map = new HashMap<>(16);
        for (int i = 0; i < nums.length; i++) {
            int pos = map.getOrDefault(target - nums[i], -1);
            if (pos >= 0) {
                return new int[]{pos, i};
            } else {
                map.put(nums[i], i);
            }
        }
        
        return array;
    }
}
```

![哈希法](images/leetcode_20201003155647.png)

#### 2. 两数相加

> 原题链接：https://leetcode-cn.com/problems/add-two-numbers/

**题目描述**

> 给出两个 **非空** 的链表用来表示两个 **非负** 的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储一位数字。
>
> 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
>
> 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
> **示例：**
>
> ```
> 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
> 输出：7 -> 0 -> 8
> 原因：342 + 465 = 807
> ```

**思路分析**

> 此题可以看作连个链表的合并的变式题，从低位开始相加，同时需要记录进位数合并到下一位的加法运算中。

**参考代码**

方法一：模拟法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode merge = new ListNode(0);
        ListNode p = merge;
        int bit = 0, x, y, s;
        while (l1 != null || l2 != null) {
            x = l1 != null ? l1.val : 0;
            y = l2 != null ? l2.val : 0;
            s = (x + y + bit) % 10;
            bit = (x + y + bit) / 10;
            
            p.next = new ListNode(s);
            p = p.next;
            l1 = l1 != null ? l1.next : null;
            l2 = l2 != null ? l2.next : null;
        }

        if (bit != 0) {
            p.next = new ListNode(bit);
        }

        return merge.next;
    }
}
```

运行结果如下：

![模拟法](images/leetcode_20201004104939.png)

#### 0. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

方法一：暴力优化解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

运行结果如下：

![]()

#### 0. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

方法一：暴力优化解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

运行结果如下：

![]()

#### 0. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

方法一：暴力优化解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

运行结果如下：

![]()

#### 0. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

方法一：暴力优化解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

运行结果如下：

![]()

#### 0. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

方法一：暴力优化解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

运行结果如下：

![]()

#### 0. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

方法一：暴力优化解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

运行结果如下：

![]()

#### 9. 回文数（☑️）

> 原题链接：https://leetcode-cn.com/problems/palindrome-number/

**题目描述**

>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**思路分析**

> 由于整数的特殊性，如果为负数，则易知不是回文数（因为整数的末尾不可能出现符号）。
>
> 方法一：此题最容易想到的就是把数字转成字符串 `str`，然后用双指针法(`low`，`high`)进行首尾遍历，当 `str[low] != str[high]` 说明不是回文；否则进行下一轮，`low++，high--` ，直到`low >= high` 循环结束。
>
> 方法二：方法一是常规的字符串解法，没有充分利用本题的整数这一条件，回文数是指整数的前部分（负数除外）和后半部分形成对称，也就是说只要将整数拆成位数相等（如果整数的奇数位去中间位）的两部分并且将后半部分翻转与前半部分相比，如相等则说明是回文数，否则不是。需要处理的问题有：1）整数翻转，定义一个新的整型变量 `reverse`，循环每次取 `x` 的个位数，然后 `reverse = reverse * 10 + x % 10`，同时需要将 `x = x / 10`，这样可以将`x`进行翻转；2）拆分整数`x`为两部分，本题只需要判断前半部分和翻转后的后半分部分是否相等即可，所以循环的终止条件是 `x <= reverse`，当整数 `x` 为偶数位时两数相等；当整数 `x` 为奇数位时 `x < reverse`，因为多出的中间位被添加到 `reverse` 的末尾，所以最终判断是否为回文数的条件应该为 `x == reverse || x == reverse / 10` ；3）注意特殊情况，如果 `x` 的个位数为0，那么易知整数不是回文数，2）中的最终判断条件会判定 `x = 10` 为 `true` ，这是最容易忽略的一点。

**参考代码**

- 方法一：转字符串法，时间复杂度为 $O(n/2)$，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public boolean isPalindrome(int x) {
        String value = String.valueOf(x);
        int low = 0;
        int high = value.length() - 1;
        while (low < high) {
            if (value.charAt(low) != value.charAt(high)) {
                return false;
            }
            
            low++;
            high--;
        }
        
        return true;
    }
}
```

运行结果如下：

![转字符串法](images/leetcode_20200514125544.png)

- 方法二：反转后半部分数字，时间复杂度为 $O(log_{10}n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean isPalindrome(int x) {
        boolean flag = x < 0 || (x % 10 ==0 && x != 0);
        if (flag) {
            return false;
        }

        int reverse = 0;
        while (x > reverse) {
            reverse = reverse * 10 + x % 10;
            x /= 10;
        }

        return x == reverse || x == reverse / 10;
    }
}
```

运行结果如下：

![反转后半部分数字](images/leetcode_20200514121403.png)

#### 10. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

方法一：暴力优化解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

运行结果如下：

![转字符串法]

#### 15. 三数之和 

> 原题链接：https://leetcode-cn.com/problems/3sum/

**题目描述**

> 给你一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 `a，b，c` ，使得 `a + b + c = 0` ？请你找出所有满足条件且不重复的三元组。
>
> ==注意：==
>
> > 答案中不可以包含重复的三元组。

**思路分析**

> 此题是由 [1. 两数之和](https://leetcode-cn.com/problems/two-sum/) 进阶而来的，首先对数组进行排序，然后需要层层剥变成成两数之和，采用双指针法即可完成。需要注意的点是：1）本题需要对满足要求的数组进行去重处理；2）在遍历过程中考虑边界之和与 `target` 的大小关系，进而可以优化循环体。

**参考代码**

方法一：排序 + 双指针解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(logn)+O(n)$。

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> arrays = new ArrayList<>();
        int minCount = 3;
        if (nums == null || nums.length < minCount) {
            return arrays;
        }

        Arrays.sort(nums);
        int length = nums.length;
        for (int i = 0; i < length - minCount + 1; i++) {
            // 去重
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            // 提前终止循环
            if (nums[i] + nums[i + 1] + nums[i + 2] > 0) {
                break;
            }

            // 加速循环
            if (nums[i] + nums[length - 2] + nums[length - 1] < 0) {
                continue;
            }
            
            // 变成两数之和
            int low = i + 1, high = length - 1;
            int sum = -nums[i];
            while (low < high) {

                if (nums[low] + nums[high] == sum) {
                    arrays.add(Arrays.asList(nums[i], nums[low], nums[high]));

                    while (low < high && nums[low] == nums[low + 1]) {
                        low++;
                    }
                    low++;

                    while (low < high && nums[high] == nums[high - 1]) {
                        high--;
                    }
                    high--;
                } else if (nums[low] + nums[high] < sum) {
                    low++;
                } else {
                    high--;
                }
            }
        }

        return arrays;
    }
}
```

运行结果如下：

![排序 + 双指针法](images/leetcode_20201005130503.png)

#### 18. 四数之和

> 原题链接：https://leetcode-cn.com/problems/4sum/

**题目描述**

> 给定一个包含 `n` 个整数的数组 `nums` 和一个目标值 `target`，判断 `nums` 中是否存在四个元素 `a，b，c` 和 `d` ，使得 `a + b + c + d` 的值与 `target` 相等？找出所有满足条件且不重复的四元组。
>
> ==注意：==
>
> > 答案中不可以包含重复的四元组。

**思路分析**

> 此题是由 [15. 三数之和]() 进阶而来的，首先对数组进行排序，然后需要层层剥变成三数之和，进而变成两数之和，采用双指针法即可完成。需要注意的点是：1）本题需要对满足要求的数组进行去重处理；2）在遍历过程中考虑边界之和与 `target` 的大小关系，进而可以优化循环体。

**参考代码**

方法一：排序 + 双指针解法，其时间复杂度为 $O(n^3)$，空间复杂度为 $O(logn)+O(n)$。

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> arrays = new ArrayList<>();
        int minCount = 4;
        if (nums == null || nums.length < minCount) {
            return arrays;
        }

        Arrays.sort(nums);
        int length = nums.length;
        for (int i = 0; i < length - minCount + 1; i++) {
            // 去重
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            // 提前终止循环
            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {
                break;
            }

            // 加速循环
            if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {
                continue;
            }

            // 变成三数问题
            int cnt = 2;
            for (int j = i + 1; j < length - cnt; j++) {
                // 去重
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }

                // 提前终止循环
                if (nums[j] + nums[j + 1] + nums[j + 2] + nums[i] > target) {
                    break;
                }

                // 加速循环
                if (nums[j] + nums[i] + nums[length - 2] + nums[length - 1] < target) {
                    continue;
                }

                // 变成两数之和
                int low = j + 1, high = length - 1;
                int sum = target - nums[i] - nums[j];
                while (low < high) {
                    
                    if (nums[low] + nums[high] == sum) {
                        arrays.add(Arrays.asList(nums[i], nums[j], nums[low], nums[high]));
                        
                        while (low < high && nums[low] == nums[low + 1]) {
                            low++;
                        }
                        low++;

                        while (low < high && nums[high] == nums[high - 1]) {
                            high--;
                        }
                        high--;
                    } else if (nums[low] + nums[high] < sum) {
                        low++;
                    } else {
                        high--;
                    }
                }
            }
        }
        
        return arrays;
    }
}
```

运行结果如下：

![排序+双指针法](images/leetcode_20201005122056.png)

#### 28. 实现 strStr()（☑️）

> 标题：【Leetcode刷题】字符串模式匹配算法知多少
>
> 原题链接：https://leetcode-cn.com/problems/implement-strstr/

**题目描述**

> 实现 `strStr()` 函数。
>
> 给定一个 `haystack` 字符串和一个 `needle` 字符串，在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
>
> 说明：
>
> > 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
> >
> > 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

**思路分析**

> 方法一/二：此题最先也是最容易想到的是暴力解法，但是实践证明，在 `Java` 提交中通不过，逐一判断超时，增加条件即满足首尾相等在进行判断相等，即可优化解，提交可以通过；
>
> 方法三：通过对暴力解分析，利用 `Java` 字符串截取方法，通过逐一比较子字符串可得；
>
> 方法四：前三种方法实质都是通过逐一比较子字符串求解，其实还有更进一步优化，分析发现其实并不是所有长度为 `needle.length()` 需要比较，可以利用双指针判断，具体做法是：定义两个指针 `p`，`q` 分别指向 `haystack`，`needle`，从首字符开始，如果不相等，则移动 `p`；如果两个指针指向相等，则同时移动下一位，直至 `p` 指向 `needle` 的尾字符，如果仍相等，则说明找到其位置，程序结束；否则需要从不相等的位置开始同时向前回溯（`p` 再次指向 `needle` 的首字符为止）；如此循环即可；
>
> 方法五：`Rabin Karp` 算法，其思路是先生成窗口内子串的哈希码，然后再跟 `needle` 字符串的哈希码做比较。如何在常数时间生成子串的哈希码？ 这里需要涉及到**滚动哈希**：常数时间生成哈希码，利用滑动窗口的特性，每次滑动都有一个元素进，一个出，生成一个长度为 `L` 数组的哈希码，需要 $O(L)$ 时间。算法步骤如下：
>
> > 计算子字符串 `haystack.substring(0, L)` 和 `needle.substring(0, L)` 的哈希值。
> >
> > 从起始位置开始遍历：从第一个字符遍历到第 N - L 个字符；
> >
> > 根据前一个哈希值计算滚动哈希；
> >
> > 如果子字符串哈希值与 `needle` 字符串哈希值相等，返回滑动窗口起始位置。
> >
> > 返回 -1，这时候 `haystack` 字符串中不存在 `needle` 字符串。
>
> 方法六：`BM`（`Boyer-Moore`）算法，其思想是有模式串中不存在的字符，那么肯定不匹配，往后多移动几位，提高效率，遵循**坏字符**规则，**好后缀**规则。
>
> > 1）**坏字符规则**：当文本串中的某个字符跟模式串的某个字符不匹配时，称文本串中的这个失配字符为**坏字符**，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果"坏字符"不包含在模式串之中，则最右出现位置为-1；
> >
> > 2）**好后缀规则**：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。
>
> 本题采用坏字符规则，具体做法是：首先针对模式串 `needle` 构造模式串的数组表（哈希表） `suffix` （本题是字符串默认为基本字符，`ASCII` 码是8位），然后从 `haystack` 的首字符循环遍历长度为 `needle.length()` 的子串， 跳跃为 `skip`， 用 `needle` 从后往前匹配，如果整个模式串匹配成功则 `skip=0` 终止程序，否则 `skip = j - suffix[haystack.charAt(i + j)]`，直到最后一个子串，如果未匹配成功，最后返回 `-1`。
>
> 方法七：`KMP` (`Knuth-Morris-Pratt `) 算法，基本思路如下：
>
> > 假设现在文本串 `S` 匹配到 `i` 位置，模式串 `P` 匹配到 `j` 位置：
> >
> > > 1）如果 `j = -1`，或者当前字符匹配成功（即 `S[i] == P[j]`），都令 `i++`，`j++`，继续匹配下一个字符；
> > >
> > > 2）如果 `j != -1`，且当前字符匹配失败（即 `S[i] != P[j]`），则令 `i` 不变，`j = next[j]`。此举意味着失配时，模式串 `P` 相对于文本串 `S` 向右移动了 `j - next [j]` 位。
> > >
> > > `next` 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如`next [j] = k`，代表 `j` 之前的字符串中有最大长度为 `k` 的相同前缀后缀。
>
> 算法步骤：首先求解模式串 `P` 的 `next` 数组：定义长度为 `P.length()` 的数组 `next`，遍历模式串 `P`，取 `i=-1,j=0`，若 `P.charAt(j)` 与 `P.charAt(i)` 相等，则 `j` 的下一个跳到 `i` 的下一个处，否则退回至 `next[i]`，循环结束即可得`next` 数组；然后同时循环遍历文本串 `S` 和 模式串 `P` ，根据上述思路即可完成。
>
> 方法八：`Sunday`算法，是 `Daniel M.Sunday` 于1990年提出的字符串模式匹配，其核心思想是：在匹配过程中，模式串发现不匹配时，算法能跳过尽可能多的字符以进行下一步的匹配，从而提高了匹配效率。`Sunday` 算法思想跟 `BM` 算法很相似，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符，如果该字符没有在匹配串中出现则直接跳过，即移动步长= 匹配串长度+1；否则，同 `BM` 算法一样其移动步长=匹配串中最右端的该字符到末尾的距离+1。
>
> 算法步骤：定义模式串的哈希表（本题采用数组），循环遍历 `haystack`，每次取长度为 `needle.length()` 的子串与`needle`比较，如果相等则返回对应的下标，程序结束；否则，判断 `haystack.charAt(i + needle.length())` 是否在 `needle` 中：若在则移动步长 `skip` 为1；若不在，则移动步长 `skip` 为 `i + needle.length()`，直到最后一个子串，如果未匹配成功，最后返回 `-1`。
>
> 测试用例组：
>
> > 1）`haystack` = "`hello`", `needle` = "`ll`"
> >
> > 2）`haystack` = "`aaaaa`", `needle` = "`bba`"
> >
> > 3）`haystack` = "`a`", `needle` = "`a`"
> >
> > 4）`haystack` = "`aaa`", `needle` = "`aaaa`"
> >
> > 5）`haystack` = "`mississippi`", `needle` = "`a`" 
> >
> > 6）`haystack` = "`mississippi`", `needle` = "`issi`"

**参考代码**

- ~~方法一：暴力解法，**[提交时，超出时间限制]**，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。~~

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        for (int i = 0; i < haystack.length(); i++) {
            if (haystack.charAt(i) == needle.charAt(0)) {
                boolean result = isSubStr(haystack, needle, i);
                if (result) {
                    return i;
                }
            }
        }
        
        return -1;
    }

    private boolean isSubStr(String haystack, String needle, int i) {
        for (int j = 0; j < needle.length(); j++) {
            if (i == haystack.length()) {
                return false;
            }
            
            if (haystack.charAt(i) != needle.charAt(j)) {
                return false;
            }
            
            i++;
        }
        
        return true;
    }
}
```

运行结果如下：

![暴力法](images/leetcode_20200530142931.png)

- 方法二：暴力优化解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        int len = needle.length();
        for (int i = 0; i < haystack.length(); i++) {
            if (haystack.charAt(i) == needle.charAt(0) 
                    && i + len - 1 < haystack.length()
                    && haystack.charAt(i + len - 1) == needle.charAt(len - 1)) {
                boolean result = isSubStr(haystack, needle, i);
                if (result) {
                    return i;
                }
            }
        }
        
        return -1;
    }

    private boolean isSubStr(String haystack, String needle, int i) {
        for (int j = 0; j < needle.length(); j++) {
            if (i == haystack.length()) {
                return false;
            }

            if (haystack.charAt(i) != needle.charAt(j)) {
                return false;
            }
            
            i++;
        }
        
        return true;
    }
}
```

运行结果如下：

![暴力优化法](images/leetcode_20200530143536.png)

- 方法三：字符串截取+逐一比较子字符串，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。


```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        for (int i = 0; i < haystack.length(); i++) {
            if (i + needle.length() <= haystack.length() 
            && haystack.substring(i, i + needle.length()).equals(needle)) {
                return i;
            }
        }

        return -1;
    }
}
```

运行结果如下：

![字符串截取+逐一比较子字符串](images/leetcode_20200530145406.png)

- 方法四：双指针法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        int p = 0, q, curLen;
        while (p + needle.length() - 1 < haystack.length()) {
            // 不相等，则移动p
            while (p + needle.length() - 1 < haystack.length()
                    && haystack.charAt(p) != needle.charAt(0)) {
                p++;
            }

            q = 0;
            curLen = 0;
            // 两个指针指向相等，则同时移动下一位
            while (p < haystack.length() && q < needle.length()
                    && haystack.charAt(p) == needle.charAt(q)) {
                p++;
                q++;
                curLen++;
            }

            if (curLen == needle.length()) {
                return p - curLen;
            }
            
            // 向前回溯
            p = p - curLen + 1;
        }

        return -1;
    }
}
```

运行结果如下：

![双指针法](images/leetcode_20200530154251.png)

- 方法五：`Rabin Karp` 算法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        if (haystack.length() < needle.length()) {
            return -1;
        }

        // 设置滚动哈希函数的基值--本题取a
        int base = 26;
        long module = (long)Math.pow(2, 31);

        // 计算Hash值
        long hash = 0, refHash = 0;
        for (int i = 0; i < needle.length(); i++) {
            hash = (hash * base + charToInt(haystack, i)) % module;
            refHash = (refHash * base + charToInt(needle, i)) % module;
        }

        // 首部匹配成功
        if (hash == refHash) {
            return 0;
        }

        // 计算最高位
        long bit = 1;
        for (int i = 0; i < needle.length(); i++) {
            bit = (bit * base) % module;
        }
        
        // 遍历并判断查找
        for (int i = 1; i < haystack.length() - needle.length() + 1; i++) {
            hash = (hash * base - charToInt( haystack, i - 1) * bit
                    + charToInt(haystack, i + needle.length() - 1)) % module;
            if (hash == refHash) {
                return i;
            }
        }

        return -1;
    }

    private int charToInt(String string, int i) {
        return string.charAt(i) - 'a';
    }
}
```

运行结果如下：

![RabinKarp](images/leetcode_20200530191937.png)

- 方法六：`BM` 算法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        // 构建模式串的数组表（哈希表）
        int[] suffix = generateSuffix(needle);

        int skip;
        for (int i = 0; i <= haystack.length() - needle.length(); i += skip) {
            skip = 0;
            for (int j = needle.length() - 1; j >= 0; j--) {
                if (needle.charAt(j) != haystack.charAt(i + j)) {
                    // 计算跳跃步数
                    skip = j - suffix[haystack.charAt(i + j)];
                    skip = skip < 1 ? 1 : skip;
                    break;
                }
            }

            if (skip == 0) {
                return i;
            }
        }
        return -1;
    }

    private int[] generateSuffix(String needle) {
        int max = 128;
        int[] suffix = new int[max];
        for (int i = 0; i < max; i++) {
            suffix[i] = -1;
        }

        for (int i = 0; i < needle.length(); i++) {
            suffix[needle.charAt(i)] = i;
        }
        
        return suffix;
    }
}
```

运行结果如下：

![BM算法](images/leetcode_20200530212634.png)

- 方法七：`KMP` 算法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        int[] next = getNext(needle);
        int i = 0, j = 0;
        while (i < haystack.length() && j < needle.length()) {
            if (j == -1 || haystack.charAt(i) == needle.charAt(j)) {
                i++;
                j++;
            } else {
                j = next[j];
            }
        }

        return j == needle.length() ? i - j : -1;
    }

    private int[] getNext(String pattern) {
        int[] next = new int[pattern.length()];
        next[0] = -1;
        int i = -1, j = 0;
        while (j < pattern.length() - 1) {
            if (i == -1 || pattern.charAt(j) == pattern.charAt(i)) {
                // 若相等，则j的下一个跳到i的下一个处
                next[++j] = ++i;
                if (pattern.charAt(j) == pattern.charAt(i)) {
                    //若继续相等，则再往前跳
                    next[j] = next[i];
                }
            } else {
                //不相等则移回到i处
                i = next[i];
            }
        }

        return next;
    }
}
```

运行结果如下：

![KMP算法](images/leetcode_20200530232301.png)

- 方法八：`Sunday`算法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle == null ||  needle.length() == 0) {
            return 0;
        }

        // 构建模式串的数组表（哈希表）
        int[] suffix = generateSuffix(needle);

        int skip;
        for (int i = 0; i <= haystack.length() - needle.length(); i += skip) {
            if (needle.equals(haystack.substring(i, i + needle.length()))) {
                return i;
            } else {
                skip = i + needle.length() < haystack.length()
                        && suffix[haystack.charAt(i + needle.length())] == -1
                        ? i + needle.length() : 1;
            }
        }
        return -1;
    }

    private int[] generateSuffix(String needle) {
        int max = 128;
        int[] suffix = new int[max];
        for (int i = 0; i < max; i++) {
            suffix[i] = -1;
        }

        for (int i = 0; i < needle.length(); i++) {
            suffix[needle.charAt(i)] = i;
        }

        return suffix;
    }
}
```

运行结果如下：

![Sunday算法](images/leetcode_20200531003038.png)

**参考资料**

> [官方题解](https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode/)
>
> [Rabin-Karp算法](https://blog.csdn.net/seacowtech/article/details/79256299)
>
> [子串查找算法-Rabin-Karp](https://www.jianshu.com/p/68cbe955103e)
>
> [面试算法之字符串匹配算法，Rabin-Karp算法详解](https://blog.csdn.net/tyler_download/article/details/52457108?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)
>
> [从头到尾彻底理解KMP（2014年8月22日版）](https://blog.csdn.net/v_july_v/article/details/7041827)
>
> [字符串匹配算法（BM）](https://blog.csdn.net/qq_21201267/article/details/92799488)
>
> [KMP算法和BM算法的java简单实现](https://www.jianshu.com/p/dad121ffc46f)

#### 35. 搜索插入位置（☑️）

> 原题链接：https://leetcode-cn.com/problems/search-insert-position/

**题目描述**

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 你可以假设数组中无重复元素。

**思路分析**

> 分析题意，可以理解为给一个已排好序的数组“插入”一个数，求解其插入位置。这里给出两种解法。
>
> 方法一：常规解法，逐一遍历每一个元素并与目标值比较，如果目标值大于前一个数而小于等与后一个数，那么应返回后一个数的位置，即为插入位置；如果目标值小于第一个元素应返回0；如果目标值大于最后一个元素应返回数组的长度，即为插入位置；
>
> 方法二：二分查找法，进一步探究方法一，其实质就是查找，那么可以优化查找算法，从而可以应用二分法查找，降低时间复杂度。

**参考代码**

- 方法一：常规解法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        if (nums == null || nums.length < 1) {
            return 0;
        }

        for (int i = 0; i < nums.length; i++) {
            if (target <= nums[i]) {
                return i;
            }
        }

        return nums.length;
    }
}
```

运行结果如下：

![常规解法](images/leetcode_20200601215744.png)

- 方法二：二分查找法，其时间复杂度为 $O(log{n})$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        if (nums == null || nums.length < 1) {
            return 0;
        }

        int low = 0, high = nums.length - 1, mid;
        while (low <= high) {
            mid = (low + high) / 2;
            if (target < nums[mid]) {
                high = mid - 1;
            } else if (target == nums[mid]) {
                return mid;
            } else {
                low = mid + 1;
            }
        }
        
        return low;
    }
}
```

运行结果如下：

![二分查找法](images/leetcode_20200601215004.png)

#### 46. 全排列

> 原题链接：https://leetcode-cn.com/problems/permutations/

**题目描述**

> 给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

**思路分析**

> 方法一：（递归法）从集合中依次选出每一个元素，作为排列的第一个元素，然后对剩余的元素进行全排列，如此递归处理，从而得到所有元素的全排列。
> 
> 方法二：（字典序排序） 给定两个偏序集 `A` 和 `B`, (`a`,`b`) 和 (`a′`,`b′`) 属于笛卡尔集 `A × B`，则 **字典序** 定义为(`a`,`b`) `≤` (`a′`,`b′`) 当且仅当 `a < a′` 或 (`a = a′` 且 `b ≤ b′`)。 所以给定两个字符串，逐个字符比较，那么先出现较小字符的那个串字典顺序小，如果字符一直相等，较短的串字典顺序小。例如： `abc` < `abcd` < `abde` < `afab`。
> 需要这样的一个算法，使得：
>
>> - 起点： 字典序最小的排列，1-`n` ，例如 12345；
>> - 终点： 字典序最大的排列， `n`-1， 例如 54321；
>> - 过程： 从当前排列生成字典序刚好比它大的下一个排列。

> `next_permutation` 算法
>
> > - 定义：**升序**：相邻两个位置 $a_i {\lt} a_{i +1}$，$a_i$ 称作该升序的首位；
> > - 步骤（二找、一交换、一翻转）：
> >   1）找到排列中最后（最右）一个升序的首位位置 $i$， $x =a_i$；
> >   2）找到排列中第 `i` 位右边最后一个比 $a_i$ 大的位置 $j$，$y = a_j$；
> >   3）交换 $x$，$y$；
> >   4）把第 $(i + 1)$ 位到最后的部分翻转。
>
> 方法三：回溯法
>
> ```java
> result = []
> def backtrack(路径, 选择列表):
>     if 满足结束条件:
>         result.add(路径)
>         return
>     
>     for 选择 in 选择列表:
>         做选择
>         backtrack(路径, 选择列表)
>         撤销选择
> ```
>
> 方法四：深度优先遍历（`DFS`）


**参考代码**

- 方法一：递归法，时间复杂度为 $O(n!)$，空间复杂度为 $O(n)$。

```java
import java.util.ArrayList;
import java.util.List;

public class Solution {

    List<List<Integer>> array = new ArrayList<>(16);

    public List<List<Integer>> permute(int[] nums) {
        if (nums == null || nums.length < 1) {
            return array;
        }

        calcAllPermute(nums, 0, nums.length - 1);
        return array;
    }

    private void calcAllPermute(int[] nums, int from, int to) {
        if (to < 0) {
            return;
        }
        
        if (from == to) {
            List<Integer> items = new ArrayList<>(16);
            for (int i = 0; i <= to; i++) {
                items.add(nums[i]);
            }
            array.add(items);
        } else {
            for (int i = from; i <= to; i++) {
                swap(nums, i, from);
                calcAllPermute(nums, from + 1, to);
                swap(nums, i, from);
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

运行结果如下：

![递归法](images/leetcode_20200905164743.png)

- 方法二：字典序排序，时间复杂度为 $O(n!)$，空间复杂度为 $O(n)$。

```java
import java.util.List;

class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> array = new ArrayList<>(16);
        if (nums == null || nums.length < 1) {
            return array;
        }

        Arrays.sort(nums);

        while (true) {
            List<Integer> temp = new ArrayList<>(16);
            for (int item: nums) {
                temp.add(item);
            }
            array.add(temp);
            
            if (!calcAllPermutationDic(nums)) {
                break;
            }
        }

        return array;
    }

    private boolean calcAllPermutationDic(int[] nums) {
        int i, index = 2;
        // ① 找到排列中最后(最右)一个升序的首位位置i，x=a_i
        for(i = nums.length - index; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                break;
            }
        }

        // 已经找到所有排序
        if(i < 0) {
            return false;
        }

        int k;
        // ② 找到排列中第i个右边最后一个比a_i大的位置j，y=a_j
        for(k = nums.length - 1; k > i; k--) {
            if (nums[k] > nums[i]) {
                break;
            }
        }

        // ③ 交换x，y
        nums[i] += nums[k];
        nums[k] = nums[i] - nums[k];
        nums[i] -= nums[k];

        // ④ 把第(i+1)位到最后的部分翻转
        for (int j = i + 1, m = nums.length - 1; j < m; j++, m--) {
            nums[j] += nums[m];
            nums[m] = nums[j] - nums[m];
            nums[j] -= nums[m];
        }
        return true;
    }
}
```

运行结果如下：

![字典排序](images/leetcode_20200905170916.png)

- 方法三：回溯法，时间复杂度为 $O(n!)$，空间复杂度为 $O(n)$。

```java
import java.util.List;

/**
 * def backtrack(路径, 选择列表):
 *      if 满足结束条件:
 *          result.add(路径)
 *          return
 *
 *     for 选择 in 选择列表:
 *         做选择
 *         backtrack(路径, 选择列表)
 *         撤销选择
 *
 *  @author zhangbocheng
 */
class Solution {
    private List<List<Integer>> array = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        if (nums == null || nums.length < 1) {
            return array;
        }

        Stack<Integer> track = new Stack<>();
        backTrack(nums, track);
        return array;
    }

    private void backTrack(int[] nums, Stack<Integer> track) {
        if (track.size() == nums.length) {
            array.add(new ArrayList<>(track));
            return;
        }

        for (int i: nums) {
            if (track.contains(i)) {
                continue;
            }

            track.push(i);
            backTrack(nums, track);
            track.pop();
        }
    }
}
```

运行结果如下：

![回溯法](images/leetcode_20200905173700.png)

- 方法四：`DFS` 法，时间复杂度为 $O(nlogn)$，空间复杂度为 $O(n)$。

```java
import java.util.List;

class Solution {
    private List<List<Integer>> array = new ArrayList<>(16);
    public List<List<Integer>> permute(int[] nums) {
        if (nums == null || nums.length < 1) {
            return array;
        }

        Stack<Integer> depth = new Stack<>();
        boolean[] visited = new boolean[nums.length];
        dfs(nums, 0, depth, visited);
        return array;
    }

    private void dfs(int[] nums, int depth, Stack<Integer> path, boolean[] visited) {
        if (depth == nums.length) {
            array.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (visited[i]) {
                continue;
            }

            path.add(nums[i]);
            visited[i] = true;
            dfs(nums, depth + 1, path, visited);
            path.pop();
            visited[i] = false;
        }
    }
}
```

运行结果如下：

![DFS法](images/leetcode_20200905175100.png)

#### 60. 第k个排列

> 原题链接：https://leetcode-cn.com/problems/permutation-sequence/

**题目描述**

> 给出集合 $[1,2,3,\dots,n]$ ，其所有元素共有 $n!$ 种排列。
>
> 按大小顺序列出所有排列情况，并一一标记，当 $n = 3$ 时, 所有排列如下：
>
> ```
> "123"
> "132"
> "213"
> "231"
> "312"
> "321"
> ```
>
> 给定 `n` 和 `k`，返回第 `k` 个排列。
>
> ==说明：==
>
> > 给定 `n` 的范围是 [1, 9]。
> > 给定 `k` 的范围是[1, n!]。

**思路分析**

> 方法一：字典序排序，参考题46中的字典序排序思路，不同之处在于求第 `k` 个序列，增加一个计数器即可。

**参考代码**

方法一：字典序排序，时间复杂度为 $O(n!)$，空间复杂度为 $O(n)$。

```java
import java.util.ArrayList;
import java.util.List;

public class Solution {
    public String getPermutation(int n, int k) {
        int[] nums = new int[n];
        for (int i = 1; i <= n; i++) {
            nums[i-1] = i;
        }

        while (true) {
            List<String> temp = new ArrayList<>(16);
            for (int num: nums) {
                temp.add(String.valueOf(num));
            }

            k--;
            if (k == 0) {
                return String.join("", temp);
            }

            if (!next(nums)) {
                break;
            }
        }

        return null;
    }

    private boolean next(int[] nums) {
        int i, index = 2;
        for (i = nums.length - index; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                break;
            }
        }

        if (i < 0) {
            return false;
        }

        int k;
        for (k = nums.length - 1; k > i; k--) {
            if (nums[k] > nums[i]) {
                break;
            }
        }

        nums[i] += nums[k];
        nums[k] = nums[i] - nums[k];
        nums[i] -= nums[k];

        for (int j = i + 1, m = nums.length - 1; j < m; j++, m--) {
            nums[j] += nums[m];
            nums[m] = nums[j] - nums[m];
            nums[j] -= nums[m];
        }

        return true;
    }
}
```

运行结果如下：

![转字符串法](images/leetcode_20200905200300.png)

#### 75. 颜色分类 

> 原题链接：https://leetcode-cn.com/problems/sort-colors/

**题目描述**

> 给定一个包含红色、白色和蓝色，一共 `n` 个元素的数组，**原地** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
>
> 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
>
> ==注意:==
>
> > 不能使用代码库中的排序函数来解决这道题。
>
> 示例:
>
> > 输入: [2,0,2,1,1,0]
> > 输出: [0,0,1,1,2,2]
>
> ==进阶：==
>
> > 1）一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
> >
> > 2）你能想出一个仅使用常数空间的一趟扫描算法吗？

**思路分析**

> 方法一：（计数排序法）根据进阶提示，两趟扫描，一趟统计每个数的个数；一趟根据统计结果直接重写当前数组即可；
>
> 方法二：（双指针法）使用两个指针分别用来交换 0 和 1。

**参考代码**

方法一：计数排序法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public void sortColors(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return;
        }

        int count0 = 0, count1 = 0, count2 = 0;
        for (int num : nums) {
            if (num == 0) {
                count0++;
            } else if (num == 1) {
                count1++;
            } else {
                count2++;
            }
        }
        
        int index = 0;
        while (count0 > 0 || count1 > 0 || count2 > 0) {
            if (count0 > 0) {
                nums[index++] = 0;
                count0--;
                continue;
            }

            if (count1 > 0) {
                nums[index++] = 1;
                count1--;
                continue;
            }

            nums[index++] = 2;
            count2--;
        }
    }
}
```

运行结果如下：

![计数排序法](images/leetcode_20201007204156.png)

方法二：计数排序法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public void sortColors(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return;
        }

        // slow 来交换 0；quick 来交换 1.
        int slow = 0, quick = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) {
                swap(nums, i, slow);
                if (slow < quick) {
                    swap(nums, i, quick);
                }
                
                slow++;
                quick++;
            } else if (nums[i] == 1) {
                swap(nums, i, quick);
                quick++;
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

运行结果如下：

![双指针法](images/leetcode_20201007214918.png)

#### 107. 二叉树的层次遍历 II

> 原题链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/

**题目描述**

> 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
>
> 例如：
> 给定二叉树 [3,9,20,null,null,15,7]，
>
>     3
>     / \
>     9  20
>     /  \
>     15   7
> 返回其自底向上的层次遍历为：
>
> ```
> [
>   [15,7],
>   [9,20],
>   [3]
> ]
> ```

**思路分析**

> 这是一道常规的 `BFS` 变式题，只需要在遍历时记下每一层的节点数，在出队时作为局部整体数组输出到最终结果中。

**参考代码**

- 方法一：BFS法，时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
import java.util.*;

class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> arrays = new ArrayList<>();
        if (root == null) {
            return arrays;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int levelCount;
        while (!queue.isEmpty()) {
            levelCount = queue.size();
            List<Integer> lever = new ArrayList<>();
            for (int i = 0; i < levelCount; i++) {
                TreeNode node = queue.poll();
                lever.add(node.val);
                
                if (node.left != null) {
                    queue.offer(node.left);
                }
                
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            
            arrays.add(0, lever);
        }
        
        return arrays;
    }
}
```

运行结果如下：

![BFS法](images/leetcode_20200906092602.png)

#### 141. 环形链表

> 原题链接：https://leetcode-cn.com/problems/linked-list-cycle/

**题目描述**

> 给定一个链表，判断链表中是否有环。
>
> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 -1，则在该链表中没有环。注意：`pos` 不作为参数进行传递，仅仅是为了标识链表的实际情况。
>
> 如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。
>
>  ==进阶：==
>
> > 你能用 $O(1)$（即，常量）内存解决此问题吗？
>
>  示例 1：
>
> ![demo1](images/leetcode_20201003220810.png)
>
> > 输入：`head = [3,2,0,-4], pos = 1`
> > 输出：true
> > 解释：链表中有一个环，其尾部连接到第二个节点。
>
> 示例 2：
>
> ![demo2](images/leetcode_20201003220812.png)
>
> > 输入：`head = [1,2], pos = 0`
> > 输出：`true`
> > 解释：链表中有一个环，其尾部连接到第一个节点。
>
> 示例 3：
>
> ![demo3](images/leetcode_20201003220814.png)
>
> > 输入：`head = [1], pos = -1`
> > 输出：`false`
> > 解释：链表中没有环。

**思路分析**

> 方法一：（哈希表）是不是环形链表的判断依据是一趟遍历中某个节点能否再次被访问到。依据这一判断条件，只要在遍历时把访问的节点用哈希字典保存起来，并与已访问的哈希字典中的节点比较，若存在即知为二次访问，是环形链表，立即返回，否则，直到最后一个节点结束，不是环形链表。
>
> 方法二：（快慢指针法）如果存在环形，那么经过 $N$ 圈后，快指针一定能和慢指针相遇；否则快指针会指向一个空指针，即快慢指针不可能相遇。

**参考代码**

方法一：哈希表法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }

        Map<ListNode, Integer> map = new HashMap<>(16);
        while (head != null) {
            if (map.containsKey(head)) {
                return true;
            }
            
            map.put(head, 0);
            head = head.next;
        }
        return false;
    }
}
```

运行结果如下：

![哈希表法](images/leetcode_20201003222739.png)

方法二：快慢指针法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }

        ListNode slow = head;
        ListNode quick = head.next;
        while (slow != quick) {
            if (quick == null || quick.next == null) {
                return false;
            }

            slow = slow.next;
            quick = quick.next.next; 
        }

        return true;
    }
}
```

![快慢指针法](images/leetcode_20201004102840.png)

#### 142. 环形链表 II

> 原题链接：https://leetcode-cn.com/problems/linked-list-cycle-ii/

**题目描述**

> 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。
>
> 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 -1，则在该链表中没有环。
>
> 说明：不允许修改给定的链表。
>
> ==进阶：==
>
> > 你是否可以不用额外空间解决此题？

**思路分析**

> 方法一：（哈希表）是不是环形链表的判断依据是一趟遍历中某个节点能否再次被访问到。依据这一判断条件，只要在遍历时把访问的节点用哈希字典保存起来，并与已访问的哈希字典中的节点比较，若存在即知为二次访问，是环形链表，立即返回，否则，直到最后一个节点结束，不是环形链表。
>
> 方法二：（快慢指针法，官解）如果存在环形，那么经过 $N$ 圈后，快指针一定能和慢指针相遇；否则快指针会指向一个空指针，即快慢指针不可能相遇。
>
> 设两指针起始位置相同，慢指针走一步，快指针走两步，则若存在环，那么最后相遇时一定有：**快指针经过的节点数一定是慢指针经过节点数的2倍**。利用数学知识可以推导出：**从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离。** 当两指针相遇时，我们再额外使用一个指针 `p`。起始，它指向链表头部；随后，它和慢指针每次向后移动一个位置。最终，它们会在入环点相遇。
>
> ==误解：==两指针的相遇点为环的入口点。

**参考代码ß**

方法一：哈希表法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        Map<ListNode, Integer> map = new HashMap<>(16);
        while (head != null) {
            if (map.containsKey(head)) {
                return head;
            }
            
            map.put(head, 0);
            head = head.next;
        }
        
        return null;
    }
}
```

![哈希表法](images/leetcode_20201010145403.png)

- 方法二：快慢指针法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }

        ListNode slow = head;
        ListNode quick = head;
        while (quick != null) {
            if (quick.next == null) {
                return null;
            }

            slow = slow.next;
            quick = quick.next.next;
            if (quick == slow) {
                ListNode p = head;
                while (p != slow) {
                    p = p.next;
                    slow = slow.next;
                }
                return p;
            }
        }

        return null;
    }
}
```

![快慢指针法](images/leetcode_20201010165702.png)

#### 283. 移动零 

> 原题链接：https://leetcode-cn.com/problems/move-zeroes/

**题目描述**

> 给定一个数组 `nums`，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> ==说明：==
>
> > 必须在原数组上操作，不能拷贝额外的数组。
> > 尽量减少操作次数。

**思路分析**

> 减少操作次数即要求最小的移动代价，每个需要移动的元素仅仅移动一次即可。换个思路看，既然是把 0 移动到末尾，那只需要留下非零元素，然后在数组末尾部分用0填充即可。

**参考代码**

- 方法一：最小移动法，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        if (nums == null || nums.length < 1) {
            return;
        }
        
        int i = 0, j = 0;
        for (; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[j++] = nums[i];
            }
        }
        
        while (j < nums.length) {
            nums[j++] = 0;
        }
    }
}
```

运行结果如下：

![移动零](images/leetcode_20200905120343.png)

#### 344. 反转字符串

> 原题链接：https://leetcode-cn.com/problems/reverse-string/

**题目描述**

> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `char[]` 的形式给出。
>
> 不要给另外的数组分配额外的空间，你必须**原地修改输入数组**、使用 $O(1)$ 的额外空间解决这一问题。
>
> 你可以假设数组中的所有字符都是 `ASCII` 码表中的可打印字符。

**思路分析**

> 利用双指针法，一个指针指向 `char[]` 的起始位置，一个指针指向 `char[]` 的末端位置，同时移动两指针并交换元素，直到两个指向同一个元素为止。

**参考代码**

方法一：双指针解法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public void reverseString(char[] s) {
        if (s == null || s.length <= 1) {
            return;
        }

        int high = s.length - 1, low = 0;
        while (low < high) {
            char temp = s[low];
            s[low] = s[high];
            s[high] = temp;
            low++;
            high--;
        }
    }
}
```

运行结果如下：

![双指针解法](images/leetcode_20201003001555.png)



#### 392. 判断子序列

> 原题链接：https://leetcode-cn.com/problems/is-subsequence/

**题目描述**

> 给定字符串 `s` 和 `t` ，判断 `s` 是否为 `t` 的子序列。
>
> 你可以认为 `s` 和 `t` 中仅包含英文小写字母。字符串 `t` 可能会很长（长度 ~= 500,000），而 `s` 是个短字符串（长度 <=100）。
>
> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”`ace`”是”`abcde`"的一个子序列，而”`aec`"不是）。
>
> ==后续挑战 :==
>
> > 如果有大量输入的 $S$，称作 $S_1, S_2, \dots , S_k$ 其中 $k {\ge}10亿$，你需要依次检查它们是否为 $T$ 的子序列。在这种情况下，你会怎样改变代码？

**思路分析**

> 方法一：（双指针法）初始化两个指针 `i` 和 `j`，分别指向 `s` 和 `t` 的初始位置。每次贪心地匹配，匹配成功则 `i` 和 `j` 同时右移，匹配 `s` 的下一个位置，匹配失败则 `j` 右移，`i` 不变，尝试用 `t` 的下一个字符匹配 `s`。
>
> 此题为2021年美团数据库开发笔试题的原型题。

**参考代码**

方法一：双指针法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        // i为s的下标，j为t的下标
        int i = 0, j = 0;
        while (i < s.length() && j < t.length()) {
            if (s.charAt(i) == t.charAt(j)) {
                i++;
                j++;
            } else {
                j++;
            }
        }

        return i == s.length();
    }
}
```

运行结果如下：

![双指针法](images/leetcode_20200920115828.png)

#### 404. 左叶子之和

> 原题链接：https://leetcode-cn.com/problems/sum-of-left-leaves/

**题目描述**

> 计算给定二叉树的所有左叶子之和。
>
> 示例：
>
> ```
>     3
>    / \
>   9  20
>     /  \
>    15   7
> ```
> 
> 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24。
>

**思路分析**

> 此题属于简单题，基本的二叉树遍历算法（`BFS` 和 `DFS`），对叶子结点的判断条件考查，没有陷阱。解法只给出 `BFS` 解法。

**参考代码**

- 方法一：`BFS`法，时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。 

```java
import java.util.LinkedList;
import java.util.Queue;

class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        int sum = 0;
        if (root == null) {
            return sum;
        }

        Queue<TreeNode> nodes = new LinkedList<>();
        nodes.offer(root);
        while (!nodes.isEmpty()) {
            TreeNode node = nodes.poll();
            if (node.left != null && isLeafNode(node.left)) {
                sum += node.left.val;
            }

            if (node.left != null && !isLeafNode(node.left)) {
                nodes.offer(node.left);
            }

            if (node.right != null && !isLeafNode(node.right)) {
                nodes.offer(node.right);
            }
        }

        return sum;
    }

    private boolean isLeafNode(TreeNode node) {
        return node.left == null && node.right == null;
    }
}
```

运行结果如下：

![BFS法](images/leetcode_20200919214927.png)

#### 453. 最小移动次数使数组元素相等

> 原题链接：https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/

**题目描述**

> 给定一个长度为 $n$ 的 **非空** 整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 $n - 1$ 个元素增加 1。
>
> 示例：
>
> > 输入：[1,2,3]
> >
> > 输出：3
> >
> > ==解释==
> > 只需要3次移动（注意每次移动会增加两个元素的值）：
> > [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]

**思路分析**

> 方法一：（数学法）分析题目，通过移动增加使得所有元素最终相等，换而言之，就是求最小移动次数使得数组中最小元素和最大元素达到相等。每次固定其中最大的一个元素，其他元素移动一次，这样保证移动次数最小，假定最大值固定，那么就可以得出一个结论：移动次数就是数组中每个元素与最小元素的差的总和。**误区**：移动次数为数组中最大元素与每个元素的差的总和。测试用例：[1, 1, 2147483647]
>
> 方法二：（动态规划）考虑有序数组 $a$。假设，直到 $i-1$ 位置的元素都已经相等，只需要考虑 $i$ 位的元素，将差值 $diff=a[i]-a[i-1]$ 加到总移动次数上，使得第 $i$ 位也相等，$moves=moves+diff$。
>
> 但当继续这一步时，$a[i]$ 之后的元素也会被增加 $diff$，亦即 $a[j]=a[j]+diff$，其中 $j>i$。
>
> 但当实现本方法时，不需要对这样的 $a[j]$ 进行增加。相反把 $moves$ 的数量增加到当前元素（$a[i]$）中，$a'[i]=a[i]+moves$。
>
> 简而言之，我们对数列进行排序，一直更新 $moves$ 以使得直到当前的元素相等，而不改变除了当前元素之外的元素。在整个数组扫描完毕后，$moves$ 即为答案。
>

**参考代码**

- 方法一：数学法，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。 

```java
class Solution {
    public int minMoves(int[] nums) {
        int min = nums[0];
        for (int item: nums) {
            if (min > item) {
                min = item;
            }
        }

        int sum = 0;
        for (int item: nums) {
            sum += item - min;
        }

        return sum;
    }
}
```

运行结果：

![数学法](images/leetcode_20200904102621.png)

方法二：动态规划，时间复杂度为 $O(nlogn)$，空间复杂度为 $O(1)$。

```java
public class Solution {
    public int minMoves(int[] nums) {
        int moves = 0, diff;
        Arrays.sort(nums);

        for (int i = 1; i < nums.length; i++) {
            diff = moves + nums[i] - nums[i - 1];
            nums[i] += moves;
            moves += diff;
        }

        return moves;
    }
}
```

![动态规划](images/leetcode_20200904112608.png)

#### 523. 连续的子数组和

> 原题链接：https://leetcode-cn.com/problems/continuous-subarray-sum/

**题目描述**

> 给定一个包含非负数的数组和一个目标整数 $k$，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为2，且总和为 $k$ 的倍数，即总和为 $n*k$，其中 $n$ 也是一个整数。
>

**思路分析**

> 方法一：（暴力法）每次移动的时候，需要从起始位置逐个检测去掉之前元素的和 `sum` 能否被目标整数 `k` 整除。注意子数组元素个数最小为2；
>
> 方法二：（`HaspMap` + 前缀和法）遍历数组，记录到当前位置为止的 `sum` （`sum = sum % k`）。一旦找到新的 `sum` 的值（即在 `HashMap` 中没有这个值），就往 `HashMap` 中插入一条记录 `sum`。假设第 `i` 个位置的 `sum` 的值为 `rem`。如果以 `i` 为左端点的任何子数组的和是 `k` 的倍数，比如这个位置为 `j` ，那么 `HashMap` 中第 `j` 个元素保存的值为 `(rem + n * k) % k`，其中 `n` 是某个大于 0 的整数。结果发现：发现 `( rem + n ∗ k) % k = rem` ，也就是跟第 `i` 个元素保存到 `HashMap` 中的值相同，即得结论：无论何时，只要相同的 `sum` 的值再次被放入 `HashMap` 中，代表着有两个索引 `i` 和 `j`，它们之间元素的和是 `k` 的整数倍；
>
> 方法三：（动态规划）分别算出长度为 $2,3,{\dots},m$ 的子数组的和，判断是否为 $k$ 的倍数即可。具体方法是：将 `nums` 的数据拷贝到 `dp` 中，计算长度为2的子数组和时，$dp[j] = dp[j] + nums[j+1]$；这里的 $dp[j]$ 就是 $nums[j]$ ；计算长度为3的子数组和时，$dp[j] = dp[j] + nums[j+2]$；这里的 $dp[j]$ 是更新过的 $dp[j]$ ，一个 $dp[j]$ 相当于 $nums[j]+nums[j+1]$ … 这样当计算长度为 $p$ 的子数组大小时，就可以利用已经计算过的长度为 $p-1$ 的子数组进行更新，就可以对原来的三重循环进行优化，变为二重循环。
>
> 测试用例：
>
> > 1）目标值为 0
> >
> > 2）[0,1,0,1,0,1] 0
> >
> > 3）[0,0,1,2,0] 0
>
> 这是云从科技2021校招 `Java` 开发工程师笔试题，当时采用方法一只 `AC` 0.6，主要原因有两点：1）没有考虑目标整数为0的情况；2）忘记暴力子数组和每次应归零。

**参考代码**

- 方法一：暴力法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int sum = nums[0], pre, s;
        for (int i = 1; i < nums.length; i++) {
            sum += nums[i];
            if ((k == sum) || (k != 0 && sum % k == 0)) {
                return true;
            }
            pre = 0;
            s = sum;
            while (i - pre > 1) {
                s -= nums[pre];
                pre++;
                if ((k == s) || (k != 0 && s % k == 0)) {
                    return true;
                }
            }
        }

        return false;
    }
}
```

运行结果如下：

![暴力法](images/leetcode_20200919235415.png)

- 方法二：`HaspMap` + 前缀和法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        if (nums == null || nums.length < 1) {
            return false;
        }

        Map<Integer, Integer> map = new HashMap<>(16);
        int sum = 0;
        map.put(0,-1);
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (k != 0) {
                sum = sum % k;
            }

            if (map.containsKey(sum)) {
                if (i - map.get(sum) > 1) {
                    return true;
                }
            } else {
                map.put(sum, i);
            }
        }

        return false;
    }
}
```

运行结果如下：

![HaspMap+前缀和法](images/leetcode_20200920094134.png)

方法三：动态规划，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        if (nums == null || nums.length < 1) {
            return false;
        }

        int[] dp = new int[nums.length];
        System.arraycopy(nums, 0, dp, 0, nums.length);

        int count = 2;
        while (count <= nums.length) {
            for (int i = 0; i + count - 1 < dp.length; i++) {
                dp[i] += nums[i + count - 1];
                if (k == 0 && dp[i] == 0) {
                    return true;
                }

                if (k != 0 && dp[i] % k == 0) {
                    return true;
                }
            }
            count++;
        }

        return false;
    }
}
```

![动态规划](images/leetcode_20200920163907.png)

#### 560. 和为K的子数组（☑️）

> 原题链接：https://leetcode-cn.com/problems/subarray-sum-equals-k/

**题目描述**

> 给定一个整数数组和一个整数 $k$，你需要找到该数组中和为 $k$ 的连续的子数组的个数。
>

**思路分析**

> 方法一：此题最容易想到的暴力解法即枚举法，从数组的第一个元素开始，累加求和 `sum` 直到数组的最后一个元素结束（数组是无序，需要求的是连续的子数组，千万不能满足找到了第一个子数组就跳出循环，这是很容易忽略的地方），用一个整型变量`counts` 记录 `sum == k` 的个数，然后对第 `2～n` 做同样的处理，最后把每次循环后得到的 `counts` 累加便是本题的答案。注意此方法解题需要注意的几个特例（需要处理的细节问题）：
>
> > 1）子数组可能只含一个元素，如 `[1,1,3] 3`；
> >
> > 2）子数组可能就是整个数组，如 `[28,54,7,-70,22,65,-6] 100`；
> >
> > 3）以某个元素开始的满足条件的子数组可能不止一个，如 `[0,0,0,0,0,0,0,0,0,0] 0`。
>
> 方法二：前缀和+哈希优化法，此方法最不容易想到。对方法一进行优化分析，定义一个新的整型数组 `pre` ，用 `pre[i]` 记录数组的前 `i` 项和，容易得到递推公式：
> $$
> pre[i] = pre[i-1]+nums[i]
> $$
> 那么在 `[j ... i]` 中，和为 `k` 为的条件可表示为：
> $$
> pre[i]-pre[j-1]==k
> $$
> 所以考虑以 `i` 结尾的和为 `k` 的连续子数组个数时只要统计有多少个前缀和为 `pre[i]-k` 的 `pre[j]` 即可。为了简化 `pre` 操作可以用 `hashMap` 存储，定义为 `map`，`key` 为和值 `pre[i]`，`value` 为对应 `pre[i]` 出现的次数，从左往右边更新 `map` 边计算答案，那么以 `i` 结尾的答案 `map[pre[i]−k]` 即可在 $O(1)$ 时间内得到，最终答案即为所有下标结尾的和为 `k` 的子数组个数之和。
>

**参考代码**

- 方法一：暴力枚举法，时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0;
        if (nums == null || nums.length < 1) {
            return count;
        }

        for (int i = 0; i < nums.length; i++) {
            count += getSums(nums, i, k);
        }
        
        return count;
    }

    private int getSums(int[] nums, int i, int k) {
        int counts = 0;
        int sum = nums[i];
        if (sum == k) {
            counts++;
        }

        while (i < nums.length - 1) {
            sum += nums[++i];
            if (sum == k) {
                counts++;
            }
        }

        return counts;
    }
}
```

运行结果如下：

![暴力枚举法](images/leetcode_20200515012859.png)

- 方法二：前缀和+哈希优化，时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0, pre = 0;
        if (nums == null || nums.length < 1) {
            return count;
        }

        HashMap<Integer, Integer> map = new HashMap<>(16);
        map.put(0,1);
        for (int i = 0; i < nums.length; i++) {
            pre += nums[i];
            if (map.containsKey(pre - k)) {
                count += map.get(pre - k);
            }

            map.put(pre, map.getOrDefault(pre, 0) + 1);
        }

        return count;
    }
}
```

运行结果如下：

![前缀和哈希优化](images/leetcode_20200515102934.png)

#### 680. 验证回文字符串 Ⅱ（☑️）

> 原题链接：https://leetcode-cn.com/problems/valid-palindrome-ii/

**题目描述**

> 给定一个非空字符串 `s`，**最多**删除一个字符。判断是否能成为回文字符串。
>
> **注意：** 字符串只包含从 `a-z` 的小写字母。字符串的最大长度是50000。

**思路分析**

> 这题是回文判断的一个变式题，主要还是考查对双指针的理解。用 `low` 和 `high` 分别指向字符串 `s` 的首位和末尾，如果二者相等，则执行 `low++` ，`high--` ；如果不相等，则需要分两种情况：
>
> > 1）第 `low + 1` 位与第 `high` 位相等，依次循环判断，如果为回文字符串，则返回 `true` ，否则返回 `false` ，记为 `usedLeft`；
> >
> > 2）第 `low` 位与第 `high - 1` 位相等，依次循环判断，如果为回文字符串，则返回 `true` ，否则返回 `false` ，记为 `usedRight`。
>
> 最后，综合不等情况判断，只要不等情况1）和2）中有一个符合回文字符串，那么都应该返回 `true`，即判断条件应为  `usedLeft||usedRight`	；跳出循环如果还没返回值，说明是标准的回文串，应返回 `true`。
>
> 做题过程中，对不等判断很容易忽视情况1）和2）是**或**的关系判断， 即忽略判断两边都可以的情况（**贪心算法思想**）。如测试实例：`"aguokepatgbnvfqmgmlcupuufxoohdfpgjdmysgvhmvffcnqxjjxqncffvmhvgsymdjgpfdhooxfuupuculmgmqfvnbgtapekouga"`。

**参考代码**

- 双指针法，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public boolean validPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return false;
        }

        int low = 0, high = s.length() - 1;
        while (low < high) {
            if (s.charAt(low) == s.charAt(high)) {
                low++;
                high--;
                continue;
            }

            int left = low + 1, right = high - 1;
            boolean usedLeft = isPalindrome(s, left, high);
            boolean usedRight = isPalindrome(s, low, right);
            return usedLeft || usedRight;
        }

        return true;
    }

    private boolean isPalindrome(String s, int low, int high) {
        while (low < high) {
            if (s.charAt(low) != s.charAt(high)) {
                return false;
            }
            
            low++;
            high--;
        }
        
        return true;
    }
}
```

运行结果如下：

![双指针法](images/leetcode_20200519104743.png)

#### 771. 宝石与石头

> 原题链接：https://leetcode-cn.com/problems/jewels-and-stones/

**题目描述**

> 给定字符串 `J` 代表石头中宝石的类型，和字符串 `S` 代表你拥有的石头。 `S` 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
>
> `J` 中的字母不重复，`J` 和 `S` 中的所有字符都是字母。字母区分大小写，因此”`a`”和”`A`"是不同类型的石头。
>
> 示例 1:
>
> > 输入: J = "aA", S = "aAAbbbb"
> > 输出: 3
>
> 示例 2:
>
> > 输入: J = "z", S = "ZZ"
> > 输出: 0
>
> ==注意：==
>
> > `S` 和 `J` 最多含有50个字母。
> > `J` 中的字符不重复。

**思路分析**

> 利用字典 `map` 存储 `S` 的统计结果，然后遍历 `J` ，检查统计结果，累计和便得。

**参考代码**

方法一：哈希解法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int numJewelsInStones(String J, String S) {
        if (S == null || J == null) {
            return 0;
        }

        Map<Character, Integer> map = new HashMap<>(16);
        for (int i = 0; i < S.length(); i++) {
            map.put(S.charAt(i), map.getOrDefault(S.charAt(i), 0) + 1);
        }
        
        int total = 0;
        for (int i = 0; i < J.length(); i++) {
            total += map.getOrDefault(J.charAt(i), 0);
        }
        
        return total;
    }
}
```

运行结果如下：

![哈希解法](images/leetcode_20201002213227.png)

#### 876. 链表的中间结点

- 方法一：常规思路法

```java
/**
 * 876. 链表的中间结点
 * 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。
 * 如果有两个中间结点，则返回第二个中间结点。
 *
 * 示例 1：
 * 输入：[1,2,3,4,5]
 * 输出：此列表中的结点 3 (序列化形式：[3,4,5]
 * 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
 * 注意，我们返回了一个 ListNode 类型的对象 ans，这样：
 * ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
 *
 * 示例 2：
 * 输入：[1,2,3,4,5,6]
 * 输出：此列表中的结点 4 (序列化形式：[4,5,6])
 * 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
 * 提示：
 * 给定链表的结点数介于 1 和 100 之间。
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/3/23 10:38
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode p = head;
        int count = 0;
        while (p != null) {
            count++;
            p = p.next;
        }

        int mid = count / 2 + 1;
        count = 1;
        p = head;
        while (count < mid) {
            count++;
            p = p.next;
        }
        return p;
    }
}
```

- 方法二：数组法（官方解）

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */

/**
 * 876. 链表的中间结点
 * 给定一个带有头结点 head 的非空单链表，返回链表的中间结点。
 * 如果有两个中间结点，则返回第二个中间结点。
 *
 * 示例 1：
 * 输入：[1,2,3,4,5]
 * 输出：此列表中的结点 3 (序列化形式：[3,4,5]
 * 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
 * 注意，我们返回了一个 ListNode 类型的对象 ans，这样：
 * ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
 *
 * 示例 2：
 * 输入：[1,2,3,4,5,6]
 * 输出：此列表中的结点 4 (序列化形式：[4,5,6])
 * 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
 * 提示：
 * 给定链表的结点数介于 1 和 100 之间。
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/3/23 10:38
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        final int COUNT = 100;
        ListNode[] arrayNodes = new ListNode[COUNT];
        int count = 0;
        while (head != null) {
            arrayNodes[count++] = head;
            head = head.next;
        }
        return arrayNodes[count / 2];
    }
}
```

- 方法三：快慢指针法

```java

```





#### 1431. 拥有最多糖果的孩子（☑️）

> 原题链接：https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/

**题目描述**

> 给你一个数组 `candies` 和一个整数 `extraCandies` ，其中 `candies[i]` 代表第 `i` 个孩子拥有的糖果数目。
>
> 对每一个孩子，检查是否存在一种方案，将额外的 `extraCandies` 个糖果分配给孩子们之后，此孩子有**最多**的糖果。注意，允许有多个孩子同时拥有**最多**的糖果数目。
>
> 示例 1：
>
> > 输入：`candies = [2,3,5,1,3], extraCandies = 3`
> > 输出：`[true,true,true,false,true]` 
> > **==解释==**：
> > 孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。
> > 孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
> > 孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。
> > 孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。
> > 孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
>
> 示例 2：
>
> > 输入：`candies = [4,2,1,1,2], extraCandies = 1`
> > 输出：`[true,false,false,false,false]`
> > **==解释==**：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。

**思路分析**

> 对题目理解不透彻的话，强烈建议看示例中解释，很好地帮助我们审了题意，即本题要求是：针对组内每一个小朋友手中糖果`candies[i]` ，若把额外的糖果 `extraCandies` 分配给他，判断能否达到或者超过组内糖果的最大值。因而，解答应分两步走：1）求出组内最大值 `max`；2）针对组内每一个元素加上 `extraCandies` 判断能否达到或超过最大值，若能记为 `true`，否则记为 `false`，将结果保存为一个数组并返回。

**参考代码**

- 常规解法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        List<Boolean> result = new ArrayList<>();
        if (candies == null || candies.length < 1) {
            return result;
        }

        int max = candies[0];
        for (int value: candies) {
            max = Math.max(value, max);
        }

        for (int value: candies) {
            result.add(value + extraCandies >= max);
        }
        
        return result;
    }
}
```

运行结果如下：

![常规解法](images/leetcode_20200601100250.png)

#### 1572. 矩阵对角线元素的和

> 原题链接：https://leetcode-cn.com/problems/matrix-diagonal-sum/

**题目描述**

> 给你一个正方形矩阵 `mat`，请你返回矩阵对角线元素的和。
>
> 请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。
>
> 示例：
>
> > 输入：mat = [[1,2,3],
> > 		              [4,5,6],
> >           		    [7,8,9]]
> > 输出：25
> > 解释：对角线的和为：1 + 5 + 9 + 3 + 7 = 25
> > 请注意，元素 `mat[1][1] = 5` 只会被计算一次。

**思路分析**

> 此题较为简单，主要是发现主副对角线的元素的下标规律，主对角线上的元素下标横轴和纵轴相等即有 $i=j$ ；副对角线上的元素下标横轴和纵轴之和为定值 `mat.length` 即有 $i+j=mat.length$ 。需要注意的是主副对角线上的交叉元素不能重复计算。

**参考代码**

方法一：常规解法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int diagonalSum(int[][] mat) {
        int diag = 0;
        int antDiag = 0;
        int n = mat.length;
        for (int i = 0; i < n; i++) {
            diag += mat[i][i];
            if (i != n - 1 - i) {
                antDiag += mat[i][n - i - 1];
            }
        }

        return diag + antDiag;
    }
}
```

运行结果如下：

![常规解法](images/leetcode_20201004112752.png)

#### LCP 19. 秋叶收藏集

> 原题链接：https://leetcode-cn.com/problems/UlBDOe/

**题目描述**

> 小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 `leaves`， 字符串 `leaves` 仅包含小写字符 `r` 和 `y`，其中字符 `r` 表示一片红叶，字符 `y` 表示一片黄叶。
>
> 出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。
>
> 示例 1：
>
> > 输入：`leaves = “rrryyyrryyyrr"`
> >
> > 输出：2
> >
> > ==解释：== 调整两次，将中间的两片红叶替换成黄叶，得到 “`rrryyyyyyyyrr`"
>
> 示例 2：
>
> > 输入：`leaves = “ryr"`
> >
> > 输出：0
> >
> > ==解释：== 已符合要求，不需要额外操作
>
> 提示：
>
> > `3 <= leaves.length <= 10^5`
> > `leaves` 中只包含字符 ‘`r`' 和字符 ‘`y`'

**思路分析**

> 方法一：（官解：动态规划）由于要将收藏集中树叶的排列调整成「红、黄、红」三部分，因此可以用 3 个状态分别表示其中的每一部分，即状态 0 和状态 2 分别表示前面和后面的红色部分，状态 1 表示黄色部分。
>
> 用 $f[i][j]$ 表示对于第 0 片到第 $i$ 片叶子（记为 $leaves[0{\dots}i]$）进行调整操作，并且第 $i$ 片叶子处于状态 $j$ 时的最小操作次数。推导状态转移方程：
>
> 当 $j=0$ 时，需要将第 $i$ 片叶子变成红色，并且第 $i-1$ 片叶子也只能处于 $j=0$ 的状态（因为没有编号更小的状态了），因此有状态转移方程：
>
> $$ f[i][0]=f[i−1][0]+\text{isYellow}(i) $$
>
> 其中 $\text{isYellow}(i)$ 为示性函数，当第 $i$ 片叶子为黄色时为 1，红色时为 0。
>
> 当 $j=1$ 时，需要将第 $i$ 片叶子变成黄色，而第 $i-1$ 片叶子既可以处于 $j=1$ 的状态，也可以处于 $j=0$ 的状态，选择其中的较小值，因此有状态转移方程：
>
> $$ f[i][1] = \min \{ f[i-1][0], f[i-1][1] \} + \text{isRed}(i)$$
>
> 其中 $\text{isRed}(i)$ 为示性函数，当第 $i$ 片叶子为红色时为 1，黄色时为 0。
>
> 当 $j=2$ 时，需要将第 $i$ 片叶子变成红色，而第 $i-1$ 片叶子即可以处于 $j=2$ 的状态，也可以处于 $j=1$ 的状态（注意这里不能处于 $j=0$ 的状态，因为每一种状态包含的叶子数量必须至少为 1），选择其中的较小值，因此有状态转移方程：
>
> $$f[i][2] = \min \{ f[i-1][1], f[i-1][2] \} + \text{isYellow}(i)$$
>
> 最终的答案即为 $f[n-1][2]f[n−1][2]$，其中 $n$ 是字符串 $\textit{leaves}$ 的长度，也就是树叶的总数。
>
> 方法二：（降维优化法）基本思路同方法一，用变量代替数组，降低空间复杂度。
>
> 方法三：（官解：前缀和+动态规划）从整体上将字符串划分为三段，即看作【红，黄，红】，所求需要操作的次数为三段的操作次数总和。
> $$
> \sum_{i=0}^{x}\text{isYellow}(i)+\sum_{i=x+1}^{y}\text{isRed}(i)+\sum_{i=y+1}^{n-1}\text{isYellow}(i)
> $$
>
> 记：$pR$  表示 $\text{isRed}$ 的前缀和，$pY$  表示 $\text{isYellow}$ 的前缀和。则有总和为：
> $$
> pY(n-1)+pY(x)-pR(x)-[pY(y)-pR(y)]
> $$
> 注意到：
> $$
> pY(i)+pR(i) {\equiv} i + 1
> $$
> 令 $g(x)=2pY(x)-(x+1)$ ，则有：
> $$
> g(x+1)-g(x)=2[pY(x+1)-pY(x)]-1 \\
> pY(n-1)=\frac{g(n-1)+n}{2}
> $$

状态转移方程结果：

| leaves     | r    | r    | r    | y    | y    | y    | r    | r    | y    | y    | y    | r    | r    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| `dp[i][0]` | 0    | 0    | 0    | 1    | 2    | 3    | 3    | 3    | 4    | 5    | 6    | 6    | 6    |
| `dp[i][0]` |      | 1    | 1    | 0    | 0    | 0    | 1    | 2    | 2    | 2    | 2    | 3    | 4    |
| `dp[i][0]` |      |      | 1    | 2    | 1    | 1    | 0    | 0    | 1    | 2    | 3    | 2    | 2    |

**参考代码**

方法一：动态规划法，其时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

```java
class Solution {
    public int minimumOperations(String leaves) {
        int result = 0;
        if (leaves == null || leaves.length() <= 1) {
            return result;
        }

        int length = leaves.length();
        int[][] dp = new int[length][3];
        // 	注意初始状态
        dp[0][0] = leaves.charAt(0) == 'y' ? 1 : 0;
        dp[0][1] = dp[0][2] = dp[1][2] = Integer.MAX_VALUE;
        for (int i = 1; i < length; i++) {
            int isYellow = leaves.charAt(i) == 'y' ? 1 : 0;
            int isRed = leaves.charAt(i) == 'r' ? 1 : 0;
            dp[i][0] = dp[i - 1][0] + isYellow;
            dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][1]) + isRed;
            // 右半部分必须至少从第二个元素起
            if (i > 1) {
                dp[i][2] = Math.min(dp[i - 1][1], dp[i - 1][2]) + isYellow;
            }
        }
        
        return dp[length - 1][2];
    }
}
```

运行结果如下：

![动态规划法](images/leetcode_20201005171113.png)

方法二：动态规划+降维优化法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
     public int minimumOperations(String leaves) {
        int result = 0;
        if (leaves == null || leaves.length() <= 1) {
            return result;
        }

        int length = leaves.length();
        int dp0 = leaves.charAt(0) == 'y' ? 1 : 0;
        int dp1 = Integer.MAX_VALUE, dp2 = Integer.MAX_VALUE;
        for (int i = 1; i < length; i++) {
            int isYellow = leaves.charAt(i) == 'y' ? 1 : 0;
            int isRed = leaves.charAt(i) == 'r' ? 1 : 0;

            // 右半部分必须至少从第二个元素起
            if (i > 1) {
                dp2 = Math.min(dp1, dp2) + isYellow;
            }

            dp1 = Math.min(dp0, dp1) + isRed;
            dp0 += isYellow;
        }

        return dp2;
    }
}
```

![动态规划+降维优化法](images/leetcode_20201005192411.png)

方法三：前缀和+动态规划法，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public int minimumOperations(String leaves) {
        int result = 0;
        if (leaves == null || leaves.length() <= 1) {
            return result;
        }

        int length = leaves.length();
        // 注意初始化状态
        int dp = leaves.charAt(0) == 'y' ? 1 : 0;
        int dpMin = dp;
        int ans = Integer.MAX_VALUE;
        for (int i = 1; i < length; i++) {
            int isYellow = leaves.charAt(i) == 'y' ? 1 : 0;
            dp += 2 * isYellow -1;
            if (i != length - 1) {
                ans = Math.min(ans, dpMin - dp);
            }
            
            dpMin = Math.min(dp, dpMin);
        }

        return ans + (dp + length) / 2;
    }
}
```

![前缀和+动态规划法](images/leetcode_20201005204454.png)

## 企业面试真题

#### 百度2021届校园招聘秋招笔试题

- 李华的礼物

> 题目描述：
>
> > 李华顺利地到达了巴黎，他的好友 `Peter` 带他开启了他的巴黎之旅。途中，李华遇到了许多心动的纪念品想要带回家，但是他又不想自己太累，而且他买纪念品也有相应的预算 `k`，现给出他心动的纪念品清单：共有 `n` 件，其中每件都各有其价格 `price`，重量 `weight`，心动值 `v` (其中心动值为1~5之间的数值)，需要注意的是：在心动值不同的情况下，李华会优先选择心动值大的纪念品；若心动值相同，李华会优先选择比较便宜的纪念品，具体见样例。同时给出李华在保证不累的情况下，最多能拿的物品重量 `m`。在不超过预算并且保证不累的情况下，李华最多可以带几件纪念品回家？
>
> 输入描述：
>
> > 单组输入。
> > 第1行三个正整数，分别为：纪念品件数 `n`，最多能拿的物品重量 `m`，预算 `k`。（`n<1e5，m<100，k<10000，k` 的单位为元，`m` 的重量为 `kg`）
> >
> > 第2行到第 `n+1` 行，分别为每件物品的价格 `price`，重量 `weight`，心动值 `v`。（`price<10000，weight<100`，`v` 为1~5之间的整数，`price` 的单位为元，`weight` 的重量为 `kg`）
>
> 输出描述：
>
> > 在不超过预算并且保证不累的情况下，李华最多可以带回家的纪念品件数。
>
> 样例输入：
>
> > 3 10 1000
> > 100 5 3
> > 50 3 2
> > 300 3 3
>
> 样例输出：
>
> > 2
>
> 解释：
>
> > 李华会优先选择心动值较大的礼物1，3，且总重量和预算都没超过，所以输出为2。

思路分析

> 其实想明白了挺简单的，当时感觉真脑子短路了。优先按心动值降序，然后心动值相同按照价格升序，考察的核心就是多关键字排序问题。

代码如下：

```java
package com.exam;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;

/**
 * 样例输入：
 * 3 10 1000
 * 100 5 3
 * 50 3 2
 * 300 3 3
 *
 * 样例输出：
 * 2
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/9/4 11:50
 */
public class BaiduGift {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String[] row = sc.nextLine().split(" ");
        // 礼物行数
        int n = Integer.parseInt(row[0]);
        // 可承受的总重量
        int m = Integer.parseInt(row[1]);
        // 总预算
        int k = Integer.parseInt(row[2]);

        // 构造礼物矩阵
        List<Gift> giftArray = new ArrayList<>(16);
        while (n > 0) {
            String[] items = sc.nextLine().split(" ");
            Gift gift = new Gift();
            gift.setPrice(Integer.parseInt(items[0]));
            gift.setWeight(Integer.parseInt(items[1]));
            gift.setV(Integer.parseInt(items[2]));
            giftArray.add(gift);
            n--;
        }

        System.out.println(getGiftNumber(giftArray, m, k));
    }

    private static int getGiftNumber(List<Gift> giftArray, int m, int k) {
       List<Gift> gifts = giftArray.stream()
               .sorted(Comparator.comparing(Gift::getV).reversed()
                       .thenComparing(Gift::getPrice)).collect(Collectors.toList());
       int count = 0;
       for (Gift gift: gifts) {
            m -= gift.getWeight();
            k -= gift.getPrice();
            if (m < 0 || k < 0) {
                break;
            }
            count++;
            // 验证
            System.out.printf("%d\t%d\t%d\n", gift.getPrice(), gift.getWeight(), gift.getV());
        }

       return count;
    }

    static class Gift {
        /**
         * 价格
         */
        private int price;
        /**
         * 重量
         */
        private int weight;
        /**
         * 心动值
         */
        private int v;

        public int getPrice() {
            return price;
        }

        public void setPrice(int price) {
            this.price = price;
        }

        public int getWeight() {
            return weight;
        }

        public void setWeight(int weight) {
            this.weight = weight;
        }

        public int getV() {
            return v;
        }

        public void setV(int v) {
            this.v = v;
        }
    }
}
```

- 最小计分

> 题目描述：
>
> > 小度最近在研究一个棋盘游戏，游戏规则如下：
> >
> > 一个 $N*N$ 的棋盘，每个格子里面填写有1、2、3、4这四个数字中的某一个。最开始时在第1行第1列（左上角）放置一个棋子。每次棋子可以移动至上、下、左、右四个格子中的某一个，每次只能移动一格（允许重复移动到某一个格子），在任何时刻都不允许将棋子移出棋盘。在移动时需要进行计分。如果初始格子中的数字为 $X$，目标格子中的数字为 $Y$，则本次移动计分为 $|X-Y|$（取 $X-Y$ 的绝对值），即两个格子中的数字之差。 
> >
> > 现在需要把棋子移动到第 $N$ 行第 $N$ 列（右下角），请问能够获得的最小计分为多少？
>
> 输入描述：
>
> > 单组输入。
> > 第1行为 $N$。（$1{\le}N{\le}100$）
> > 接下来N行为一个二维数组，表示棋盘上每一个格子及其对应的数字（正整数）。
>
> 输出描述：
>
> > 输出一个正整数，表示最小计分。
>
> 样例输入：
>
> > 3
> > 1 2 4
> > 1 3 1
> > 1 2 1
>
> 样例输出：
>
> > 2

#### 京东2021届校园招聘秋招笔试题

- 道具的魅力值

> 时间限制: 3000 `MS`
> 内存限制: 589824 `KB`
>
> 题目描述：
>
> > 在某网络游戏中提供了一个道具库，在道具库中每种道具均有若干件(数量已知)，游
> > 戏玩家购买一件道具将获得一定的魅力值。
> >
> > 已知每种道具的价格和魅力值，请编写一个程序， 在总价格不超过某个上限的情况下使
> > 得所购道具的魅力值之和达到最大。
>
> 输入描述：
>
> > 单组输入。
> >
> > 每组测试数据的输入有 $n+1$ 行，$n$ 表示道具的种类。
> > 第1行包含两个正整数，分别表示道具种类数 $n$ 和总价值的上限 $p$，两个数字之间
> > 用空格隔开。($n {\le} 100, p {\le} 10000$)
> >
> > 第2行到第 $n+1$ 行分别对应于第1种道具到第 $n$ 种道具的信息，每1行包含三个正
> > 整数，两个数字之间用空格隔开，三个正整数分别表示某一种道具的数量、单个
> > 道具的价格和魅力值。
>
> 输出描述：
>
> > 每组测试数据的输出只有一行，即道具魅力值的最大和。
>
> 样例输入：
>
> > 3 10
> > 2 2 3
> > 1 5 10
> > 2 4 12
>
> 样例输出：
>
> > 27

- 王子与公主

> 时间限制: 3000 `MS`
> 内存限制: 589824 `KB`
>
> 题目描述：
>
> > 在一个 $n$ 行 $m$ 列的二维地图中，王子的位置为 $(x_1,y_1)$，公主的位置为 $(x_2,y_2)$。
> > 在地图中设有一些障碍物，王子只能朝上、下、左、右四个方向行走，且不允许走出地
> > 图也不允许穿越障碍物。
> >
> > 请编写一个程序判断王子是否可以顺利走到公主所在的位置。
>
> 输入描述：
>
> > 多组输入，第1行输入一个正整数 $T$ 表示输入数据的组数。
> >
> > 对于每一组输入数据: 输入 $n+1$ 行。
> >
> > 其中，第1行输入两个正整数 $n$ 和 $m$ 表示地图的大小，$n$ 为行数，$m$ 为列数。
> > ($n {\le} 100,m {\le} 100$)
> > 接下来 $n$ 行表示地图，每一行都有 $m$ 个字符， 其中 $S$ 表示王子的位置，$E$ 表示公主
> > 的位置，`‘.’` 表示可以通行，`‘#’` 表示障碍物(不能通行)。
>
> 输出描述：
>
> > 针对每一组输入数据， 判断王子是否能够到达公主所在位置?
> >
> > 如果可以输出"YES"，否则输出"NO"。
>
> 样例输入：
>
> > ```bash
> > 2
> > 2 2
> > .E
> > S.
> > 2 2
> > #E
> > S#
> > ```
>
> 样例输出：
>
> > YES 
> > NO

#### 美团笔试2021届数据库开发秋招笔试题

- 六位数

> 时间限制： 3000 `MS`
>
> 内存限制： 589824 `KB`
>
> 题目描述：
>
> > 小团想要编写一个程序，希望可以统计在 `M` 和 `N` 之间（`M<N`，且包含 `M` 和 `N`）有多少个六位数 `ABCDEF` 满足以下要求：
> >  (1) `ABCDEF` 这六个数字均不相同，即 `A、B、C、D、E` 和 `F` 表示六个不同的数字。
> >  (2) `AB+CD=EF`。即将这个六位数拆成三个两位数，使得第1个和第2个两位数的和等于第3个两位数。
> > （注意：`AB`、`CD` 和 `EF` 都必须是正常的两位数，因此 `A`、`C` 和 `E` 都不能等于0。）
>
> 输入描述
>
> > 单组输入。
> >
> > 输入两个六位正整数 `M` 和 `N`（`M<N`），两者之间用空格隔开。
>
> 输出描述
>
> > 输出在 `M` 到 `N` 之间（包含 `M` 和 `N`）满足要求的六位数的个数。
>
> 样例输入
>
> > 100000 110000
>
> 样例输出
>
> > 0

 本题已 `AC`，代码如下：

```java
package com.exam;

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Test01 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] numbers = scanner.nextLine().split(" ");
        int m = 0, n = 0;
        try {
            m = Integer.parseInt(numbers[0]);
            n = Integer.parseInt(numbers[1]);
        } catch (Exception e) {
            System.out.println("Input error!");
            System.exit(0);
        }

        System.out.println(getBitCount(m, n));
    }

    private static int getBitCount(int m, int n) {
        int count = 0;
        if (m > n) {
            return count;
        }

        for (int i = m; i <= n; i++) {
            if (String.valueOf(i).length() < 6) {
                continue;
            }

            if (String.valueOf(i).length() > 6) {
                break;
            }

            if (isNumber(i)) {
                count += 1;
            }
        }

        return count;
    }

    private static boolean isNumber(int i) {
        String strNumber = String.valueOf(i);

        Map<Character, Integer> map = new HashMap<>(16);
        int number1 = 0;
        int number2 = 0;
        int number3 = 0;
        for (int j = 0; j < strNumber.length(); j++) {
            if (map.containsKey(strNumber.charAt(j))) {
                return false;
            } else {
                map.put(strNumber.charAt(j), j);
            }

            if(j == 1) {
                number1 = i / 10000;
            }

            if (j == 3) {
                number2 = (i / 100) % 100;
            }

            if (j == 5) {
                number3 = i % 100;
            }
        }

        return number1 > 0 && number1 + number2 == number3;
    }
}
```

- 小美的新游戏

> 时间限制： 3000 `MS`
> 内存限制： 589824 `KB`
>
> 题目描述：
>
> > 小美和小团合作开发了一款新游戏！他们相信这款游戏一定可以大火。
> >
> > 游戏规则是这样的，现在有一个方格地图，你控制一个机器人位于初始位置(`x, y`)，然后你可以向上下左右的地块移动。其中一些地块上会有得分点，经过这些点可以获得分数。当然，路上还会有一些陷阱点，如果想要通过陷阱点，就需要付出一定的分数来清除这个陷阱点。注意陷阱点付出分数清除后就会变成普通的地块。即反复经过陷阱点只需付出一次代价。同样的，得分点也只能获得一次分数。
> >
> > 小美想到了一个策划案来让这个游戏变得难一些。小美把地图和机器人的初始位置给了小团，并且告诉了小团他操控机器人的行进路线。小美想试试小团能不能算出来他的最终得分。
> >
> > 小团完美地完成了这个任务。现在，小美和小团想找一些测试人员看看这款游戏的难度如何。他们找到了你，希望你帮他们测试一下这个游戏。而你能否挑战成功呢？
> >
> >  注意分数允许为负，初始分数为0。
>
> 输入描述
>
> > 第一行四个数字 `N，M，P，Q`，表示这张地图是 `N` 行 `M` 列的，得分点的得分是 `P`，陷阱点清除的代价是 `Q`。
> >
> > 接下来 `N` 行，每行 `M` 个字符，表示这张地图。其中，字符 `S` 表示初始机器人位置。字符 `#` 表示墙壁，字符 `O` 代表得分点。字符 `X` 代表陷阱点。字符 `+` 代表普通的地块。
> >
> > 接下来一行一个连续的字符串表示机器人的移动路线，只由大写字母 `WASD` 构成，`W` 向上，`A` 向左，`S` 向下，`D` 向右。机器人可以上下左右移动。不能超出地图边界。也不能走到墙壁之上。试图走出边界和走到墙壁的行动会停留在原来的位置不动。
>
> 输出描述
>
> > 一个整数，表示小团的机器人最终获得了多少分。
>
> 样例输入
>
> >  ```
> >  6 6 20 10
> >  S#++O#
> >  OXX#X#
> >  ++++++
> >  ###XX#
> >  ++#O#+
> >  OXO++X
> >  SSDDDDDAWWSSSAWSSSADDD
> >  ```
> 
> 样例输出
> > 40
> 
> ==提示==
> > 其中地图大小对全体数据都有 $1{\le}N,M{\le}500$
> > 对于得分点分数和陷阱点分数 $P$ 和 $Q$ 对全体数据都有 $1{\le}P,Q{\le}1000$
> > 接下来是机器人行进路线，有行进路线长度小于等于100000


- 小美找朋友

> 时间限制：3000 `MS`
> 内存限制：589824 `KB`
>
> 题目描述：
>
> > 小美将自己朋友的名字写在了一块，惊讶地发现她写出的那个字符串 `S` 有一个惊人的性质：一个人是小美的朋友当且仅当她/他的名字是那个字符串的子序列。现在小团想根据那个字符串判断一个人是不是小美的朋友。
> >
> > **子序列**：一个字符串 `A` 是另外一个字符串 `B` 的子序列，当且仅当可以通过在 `B` 中删除若干个字符（也可能一个都不删），其他字符保留原来顺序，使得形成的新字符串 `B’` 与 `A` 串相等。例如，`ABC` 是 `AABDDC` 的子序列，而 `ACB` 不是 `AABDDC` 的子序列。
>
> 输入描述
>
> > 第一行两个正整数 `n，m` 分别表示小美朋友字符串 `S` 的长度，以及小团想了解是不是小美朋友的那个人的名字字符串 `T` 的长度。
> >
> > 第二行长度为 `n` 且仅包含小写字母的字符串 `S`
> >
> > 第三行长度为 `m` 且仅包含小写字母的字符串 `T`
> >
> > `max(n,m)<=200000`
>
> 输出描述
>
> > 如果小团想了解的那个人不是小美的朋友(即，`T` 不是 `S` 的子序列)，输出一行”`No`”,否则输出一行”`Yes`”，并在第二行将 `T` 对应到 `S` 中的位置之和输出出来(从1开始编号)，由于可能有多种对应方式，请输出最小的位置之和。请参见样例解释获取更详细说明。
>
> 样例输入
>
> >  6 3
> >  aabddc
> >  abc
>
>  样例输出
>
> >  Yes
> >  10
>
> ==提示==
>
> 输入样例2
>
> > 6 3
> > aabddc
> > acb
>
> 输出样例2
>
> > No
>
> ==样例解释==
>
> > 这两组样例均为题目中提到过的对子序列的说明。
> >
> > 对于样例1
> >
> > > `S=aabddc T=abc`，`T`中 `a` 可以与 `S` 中第1个字符 `a` 对应起来，`b` 可以与 `S` 中第3个字符 `b` 对应起来，`c` 可以与 `S` 中第6个字符 `c` 对应起来，这样一来就找到了一个 `S` 中的子序列(仅保留第1、3、6个字符形成的子序列)，使其与 `T` 相等。这种情况下，位置之和为 1+3+6=10；还有一种方案，是 `S` 仅保留第2、3、6个字符形成的子序列 `abc`，仍然满足与 `T` 相等的条件。但是位置之和为 2+3+6=11，并不是位置之和最小的，因而输出第一种对应方案的位置之和：10。
> >
> > 对于样例2
> >
> > > 可以保留 `S` 中的第1、3、6个字符，形成子序列 `abc`，但与 `T` 串 `acb` 不相等，因为 `b、c` 位置并不对应。可以证明，没有任何一种取 `S` 子序列的方式，可以使得取出的子序列和 `T` 相等，因而输出 `No`。


本题同源题：[392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)，已 `AC` 0.64，代码如下：
```java
package com.exam;

import java.util.Scanner;

public class Test03 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] strNumber = scanner.nextLine().split(" ");
        int m = 0, n = 0;
        try {
            n = Integer.parseInt(strNumber[0]);
            m = Integer.parseInt(strNumber[1]);
        } catch (Exception e) {
            System.out.println("Input error!");
            System.exit(0);
        }

        String s = scanner.nextLine();
        String t = scanner.nextLine();
        boolean flag = s.length() != n || t.length() != m || Math.max(s.length(), t.length()) > 200000;
        if(flag) {
            System.out.println("Input error.");
            System.exit(1);
        }
        // 检查小写字母
        for (int i = 0; i < s.length(); i++) {
            if (!(Character.isLetter(s.charAt(i)) && Character.isLowerCase(s.charAt(i)))) {
                System.out.println("Input error.");
                System.exit(1);
            }
        }

        for (int i = 0; i < t.length(); i++) {
            if (!(Character.isLetter(t.charAt(i)) && Character.isLowerCase(t.charAt(i)))) {
                System.out.println("Input error.");
                System.exit(1);
            }
        }

        int sum = getSubString(s, t);
        if (sum > -1) {
            System.out.println("Yes");
            System.out.println(sum);
        } else {
            System.out.println("No");
        }
    }

    private static int getSubString(String s, String t) {
        // sum 位序之和，i为s的下标，j为t的下标
        int sum = 0, i = 0, j = 0;
        while (i < s.length() && j < t.length()) {
            if (s.charAt(i) == t.charAt(j)) {
                sum += (i + 1);
                i++;
                j++;
            } else {
                i++;
            }
        }

        return j == t.length() ? sum : -1;
    }
}
```
- 小美的美丽树

> 时间限制： 3000 `MS`
> 内存限制： 589824 `KB`
>
> 题目描述：
>
> > 小美在观察一棵美丽的无根树。
> >
> > 小团问小美：“小美，我考考你，如果我选一个点为根，你能不能找出子树大小不超过 `K` 的前提下，子树内最大值和最小值差最大的子树的根是哪个点？多个点的话你给我编号最小的那个点就行了。”
> >
> > 小美思索一番，说这个问题难不倒他。
>
> 输入描述
>
> > 第一行两个正整数 `N` 和 `K`，表示全树有 `N` 个节点，要求子树大小不超过 `K`。
> >
> > 第二行是 `N` 个正整数空格分隔，表示每个点的点权。以点编号从1到 `N` 的顺序给出点权。
> >
> > 接下来 `N-1` 行每行两个正整数表示哪两个点之间有边相连。
> >
> > 最后一行一个正整数 `root` 表示小团所选的根节点编号为 `root`。
> >
> > $N{\le}1e5$，各点上的权值有 $1{\le}点权{\le}1e9$，对于 $K$ 有 $1{\le}K{\le}N$。
>
> 输出描述
>
> > 一行，一个正整数，含义如问题描述，输出在子树大小不超过 `K` 的前提下，子树内最大值和最小值差最大的子树的根的编号。
>
> 样例输入
>
> > 5 2
> > 1 3 2 4 5
> > 1 2
> > 2 3
> > 3 4
> > 4 5
> > 3
>
>  样例输出
>
> > 2

- 矩阵游戏

> 时间限制： 3000 `MS`
> 内存限制： 589824 `KB`
>
> 题目描述：
>
> > 小美有一个2×2的矩阵，矩阵左上角、右上角、左下角、右下角的数字分别为 `0、A、B、C`。
> >
> > 小美觉得该矩阵不够大，她按如下方法扩展该矩阵：
> >
> > 将2×2的矩阵扩展为4×4的矩阵，4×4的矩阵被分为左上角、右上角、左下角、右下角这4个2×2的矩阵，其中左上角为原2×2的矩阵，右上角为原2×2的矩阵每个位置上的数加上 `A`，左下角为原2×2的矩阵每个位置上的数加上 `B`，右下角为原2×2的矩阵每个位置上的数加上 `C`；
> >
> > 将4×4的矩阵扩展为8×8的矩阵，8×8的矩阵被分为左上角、右上角、左下角、右下角这4个4×4的矩阵，其中左上角为原4×4的矩阵，右上角为原4×4的矩阵每个位置上的数加上 `A`，左下角为原4×4的矩阵每个位置上的数加上 `B`，右下角为原4×4的矩阵每个位置上的数加上 `C`；
> >
> > ……
> >
> > 经过不断扩展，小美可以得到一个无穷大的矩阵。小美打算用该矩阵和小团玩游戏，即对小团进行 `N` 次提问，每次给出正整数 `X、Y`，并问小团矩阵上第 `X` 行第 `Y` 列上的数是多少，由于该数可能很大，只要求小团回答该数除以 `10^9` 后的余数。
>
>   输入描述
>
> > 第一行输入四个由空格隔开的整数 `A、B、C` 和 `N`（$0{\le}A,B,C<10^{9}、1{\le}N{\le}10^5$）。
> >
> > 接下来 `N` 行，每行输入两个由空格隔开的整数 `X` 和 `Y`（$1{\le}X,Y{\le}10^9$）。
>
> 输出描述
>
> > 输出 `N` 行，每行输出一个整数，第 `i` 行输出第 `i` 次提问的答案，即矩阵对应位置上的数除以 $10^9$ 后的余数。
>
> 样例输入
>
> > 1 2 3 5
> >  3 3
> >  5 6
> >  6 1
> >  8 3
> >  8 8
>
>  样例输出
>
> > 3
> > 4
> > 4
> > 7
> > 9
>
> ==提示==
>
> > 样例解释：
> > 扩展后的矩阵前8行和前8列如下：
> >   0 1 1 2 1 2 2 3
> >   2 3 3 4 3 4 4 5
> >   2 3 3 4 3 4 4 5
> >   4 5 5 6 5 6 6 7
> >   2 3 3 4 3 4 4 5
> >   4 5 5 6 5 6 6 7
> >   4 5 5 6 5 6 6 7
> >   6 7 7 8 7 8 8 9

#### 字节跳动2021届研发大数据秋招笔试题

- 兔子生兔子，兔子何其多

>时间限制：`C/C++` 1秒，其他语言2秒
>
>空间限制：`C/C++` 32768 `K`，其他语言 65536 `K`
>
>`64bit IO Format:%lld`
>
>题目描述：
>
>> 如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第 `n` 个月能繁殖成多少对兔子？（举例第1个月生1对兔子，第2个月是2对兔子）
>
>输入描述：
>
>> 第一行输入 `N` ，表示第 `N` 个月
>
>输出描述：
>
>> 数字 `R`，表示兔子的对数
>
>输入：
>
>> 5
>
>输出：
>
>> 8

- 字符串最短循环子串

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 26144 `K`，其他语言 524288 `K`
>
> `64bit IO Format:%lld`
>
> 题目描述：
>
> > 输入一个字符串，判断其是否完全循环，若是循环的，输出最短的循环子串，否则输出自身。
> >
> > 如输入 `abababab`，输出 `ab`；输入 `ab` 则输出自身 `ab`。
>
> 输入描述：
>
> > 字符串，如 `abababab`
>
> 输出描述：
>
> > 最短循环子串，如对应例子输出 `ab`
>
> 输入：
>
> > `abababab`
>
> 输出：
>
> > `ab`
>
> ==说明：==
>
> > 输入若是 `ab` ，它不是一个循环串，故输出自身 `ab`
>
> ==备注：==
>
> > 1. `abababab` 以 `ab` 为最小串循环，故输出 `ab`；
> > 2. `abcabcab` 这种不是完全循环，故输出自身 `abcabcab` ；
> > 3. 输入字符串长度不超过 $10^8$。

- 火车站选址

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 26144 `K`，其他语言 524288 `K`
>
> `64bit IO Format:%lld`
>
> 题目描述：
>
> > `A` 市规划新建一个火车站方便市民出行。这里的道路十分规整，市民从位置 $(x_1,y_1)$ 到位置 $(x_2,y_2)$ 的路程为 $|x_1-x_2|+|y_1-y_2|$，经过前期考察，初步选定了 `M` 个可以建造火车站的位置。为了尽可能节省市民到火车站的时间，市长希望新建的火车站离每位市民的总路程尽可能小。
> >
> > 请帮市长选出最合适新建火车站的位置。
>
> 输入描述：
>
> > 第一行有两个整数 `N`，`M` ，分别表示市民的人数和可以建设火车站的位置
> >
> > 后面的 `N`，每行2个整数 $x_i,y_i$ 表示第 $i$ 位市民的居住位置在 $(x_i,y_i)$
> >
> > 后面的 `M`，每行2个整数 $p_i,q_i$ 表示第 $i$ 个火车站候选位置在 $(p_i,q_i)$
> >
> > $1{\le}N,M{\le}100000$
> >
> > $-10000000{\le}x_i,y_i,p_i,q_i{\le}10000000$
> >
> > 其中 50% 的数据，$-100{\le}x_i,y_i,p_i,q_i{\le}100$
>
> 输出描述：
>
> > 两个整数 $p_i,q_i$ 表示最合适新建火车站的位置，若有多个答案，输出原始数据中第一个出现的。
>
> 输入：
>
> > 4 3
> >
> > -1 -1
> >
> > -1 1
> >
> > 1 -1
> >
> > 1 1
> >
> > 3 2
> >
> > 1 0
> >
> > 0 0
>
> 输出：
>
> > 1 0
>
> ==说明：==
>
> > （3，2）距离所有市民总路程为20，（1，0）和（0，0）距离所有市民总路程为8；（1，0）出现在输入数据中的顺序较早，故输出（1，0）。

#### 好未来2021届大数据开发秋招笔试题

- 有序数组合并并排序，并去重，要求时间复杂度为 $O(m+n)$

>时间限制：`C/C++` 1秒，其他语言2秒
>
>空间限制：`C/C++` 51200 `K`，其他语言 102400 `K`
>
>`64bit IO Format:%lld`
>
>语言限定：`Java(javac1.8),Python(2.7.3),Python3(3.5.2)`
>
>题目描述：
>
>> 对于两个有序数组 `arrayM`，`arrayN`，长度分别为 `m` 和 `n` ，将这两个数组合并成一个数组并进行排序和去重，最终输出字符串。
>
>输入描述：
>
>> 两个有序数组。
>
>输出描述：
>
>> 去重后的数组，并排序，最终输出字符串。
>
>输入：
>
>> 1,2,4,6 2,3,4,5
>
>输出：
>
>> 1,2,3,4,5,6

`AC` 代码如下：

```java
package com.exam;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * interview
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/9/22 20:36
 */
public class MergeArray {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String[] arrays = sc.nextLine().split(" ");
        List<Integer> array1 = new ArrayList<>(16);
        List<Integer> array2 = new ArrayList<>(16);
        List<Integer> array3 = new ArrayList<>(16);
        String[] s1 = arrays[0].split(",");
        String[] s2 = arrays[1].split(",");
        for (String s: s1) {
            array1.add(Integer.parseInt(s));
        }
        for (String s: s2) {
            array2.add(Integer.parseInt(s));
        }

        array3 = getMerge(array1, array2);
        for (int i = 0; i < array3.size(); i++) {
            System.out.printf("%d ", array3.get(i));
        }
    }

    private static List<Integer> getMerge(List<Integer> array1, List<Integer> array2) {
        int i = 0, j = 0, count = -1, min;
        List<Integer> result = new ArrayList<>(16);
        while (i < array1.size() && j < array2.size()) {
            if (array1.get(i) <= array2.get(j)) {
                min = array1.get(i);
                if (count > -1 && result.get(count) != min) {
                    count++;
                    result.add(count, min);
                } else if (count == -1) {
                    count++;
                    result.add(count, min);
                }
                i++;
            } else {
                min = array2.get(j);
                if (count > -1 && result.get(count) != min) {
                    count++;
                    result.add(count, min);
                } else if (count == -1) {
                    count++;
                    result.add(count, min);
                }
                j++;
            }
        }

        while (i < array1.size()) {
            min = array1.get(i);
            if (count > -1 && result.get(count) != min) {
                count++;
                result.add(count, min);
            } else if (count == -1) {
                count++;
                result.add(count, min);
            }
            i++;
        }

        while (j < array2.size()) {
            min = array2.get(j);
            if (count > -1 && result.get(count) != min) {
                count++;
                result.add(count, min);
            } else if (count == -1) {
                count++;
                result.add(count, min);
            }
            j++;
        }

        return result;
    }
}
```

优化一：

```java
package com.exam;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * interview
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/9/22 20:36
 */
public class MergeArray {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String[] arrays = sc.nextLine().split(" ");

        int[] array1 = generateArray(arrays[0]);
        int[] array2 = generateArray(arrays[1]);

        List<Integer> array = merge(array1, array2);
        for (Integer integer : array) {
            System.out.printf("%d ", integer);
        }
    }

    private static int[] generateArray(String array) {
        String[] strings = array.split(",");
        int[] result = new int[strings.length];
        for (int i = 0; i < strings.length; i++) {
            result[i] = Integer.parseInt(strings[i]);
        }

        return result;
    }

    public static List<Integer> merge(int[] array1, int[] array2) {
        List<Integer> array = new ArrayList<>(16);
        int i = array1.length - 1, j = array2.length - 1;
        while (i >= 0 && j >= 0) {
            if (array1[i] <= array2[j]) {
                insertArray(array, array2[j]);
                j--;
            } else {
                insertArray(array, array1[i]);
                i--;
            }
        }

        while (i >= 0) {
            insertArray(array, array1[i--]);
        }

        while (j >= 0) {
            insertArray(array, array2[j--]);
        }

        return array;
    }

    private static void insertArray(List<Integer> array, int i) {
        if (array.size() > 0) {
            if (i != array.get(0)) {
                array.add(0, i);
            }
        } else {
            array.add(0, i);
        }
    }
}
```

- 无重复字符的最长子串

>时间限制：`C/C++` 1秒，其他语言2秒
>
>空间限制：`C/C++` 51200 `K`，其他语言 102400 `K`
>
>`64bit IO Format:%lld`
>
>题目描述：
>
>> 给定一个字符串和其长度，找出其中最长不含重复字符的子串，输出其子串的长度。
>
>输入描述：
>
>> 字符串及其长度。
>
>输出描述：
>
>> 不含重复字符的子串长度。
>
>输入：
>
>> “accd” 4
>
>输出：
>
>> 2

`AC`代码如下：

```java
package com.exam;

import java.util.HashSet;
import java.util.Set;

/**
 * interview
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/9/22 21:05
 */
public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * @param Str string字符串 字符串
     * @param len int整型 字符长度
     * @return int整型
     */
    public int lenSubstring (String Str, int len) {
        int max = 0;
        Set<Character> set;
        for (int i = 0; i < len; i++) {
            set = new HashSet<>(16);
            set.add(Str.charAt(i));
            for (int j = i + 1; j < len; j++) {
                if (set.contains(Str.charAt(j))) {
                    break;
                } else {
                    set.add(Str.charAt(j));
                }
            }
            max = Math.max(max, set.size());
        }

        return max;
    }
}
```

> 注意：[原题再现【3. 无重复字符的最长子串】](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

#### 竞技世界2021届秋招产品研发卷

- 最近公共祖先节点

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 51200 `K`，其他语言 102400 `K`
>
> `64bit IO Format:%lld`
>
> 题目描述：
>
> > 输入一个数组表示完全二叉树，给定两个值，求这两个值所在节点的最近公共祖先节点。
> >
> > 1. 返回最近公共祖先节点的值；
> > 2. 如果给定的两个值对应多个节点，能找到多个最近公共祖先节点，返回后续遍历这颗二叉树遇到的第一个公共祖先节点；
> > 3. 如果没有找到，返回-1。
>
> 输入：
>
> > [5,2,4,1,6,9,0,3],3,6
>
> 输出：
>
> > 2
>
> 输入：
>
> > [8,2,5,6,3,3,1,1],1,3
>
> 输出：
>
> > 2

- 硬币最多

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 262144 `K`，其他语言 524288 `K`
>
>`64bit IO Format:%lld`
>
> 题目描述：
>
>> 有 `n` 个不同面值的硬币（`n`为偶数），将 `n` 个硬币排成一排，现在你和另一个玩家轮流从这一排硬币的开头或者结尾拿走一个硬币；假设你第一个开始拿硬币，对方玩家也和你一样聪明，计算你最多能拿走多少面值的硬币？
>
> 输入：
>
>> [6,4,8,11]
>
> 输出：
>
>> 17
>
> ==说明：==
>
>> 这一排硬币的面值为6，4，8，11。你能最多拿走17（11+6）面值的硬币。
>>
>> 第一轮你拿11，对手拿8。
>>
>> 第二轮你拿6，对手拿4。
>
>输入：
>
>> [9,16,4,8]
>
>输出：
>
>> 24
>
> ==说明：==
>
>> 这一排硬币的面值为9，16，4，8。你能最多拿走24（16+8）面值的硬币。
>>
>> 第一轮你拿8，对手拿9。
>>
>> 第二轮你拿16，对手拿8。

#### 58同城2021届秋招后端研发卷

- 排队

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 51200 `K`，其他语言 102400 `K`
>
> `64bit IO Format:%lld`
>
> 题目描述：
>
> > 某企业在年终给优秀同学发放奖品时需要排队领取，由于男同学和女同学发放的奖品不同，为了提高发放效率，需要在发放奖品前先将队伍中的男同学排到一起，女同学排到一起。
> >
> > 排队调换规则：只能挨个调换位置，不能跨越调换。
> >
> > 我们用 `B` 字母代表男同学，用 `G` 字母代表女同学，输入一行只包含 `B` 和 `G` 的字符串（即男女同学排队领奖品），使用你熟悉语言编程的方式计算出最少需要多少次调换才能将男同学和女同学分开排好么？
>
> 输入： 
>
> > “`GGBBG`”
>
> 输出：
>
> > 2
>
> ==说明==：
>
> > 调换过程是：第一次调换：`GGBGB` ，第一次调换：`GGGBB` 。
>
> ==备注==：
>
> > 输入的字符串只能包含 `G` 和 `B`。

- 删除重复元素

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 262144 `K`，其他语言 524288 `K`
>
> `64bit IO Format:%lld`
>
> 题目描述：
>
> > 给定一个数组，你需要删除其中重复出现的元素，只保留最后一次出现的重复元素，使得每个元素只出现一次，返回新数组，并保证新数组中的元素顺序与原数组一致。
>
> 输入：
>
> > [3,5,8,2,3,8]
>
> 输出：
>
> > [5,2,3,8]
>

- 二叉树遍历

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 262144 `K`，其他语言 524288 `K`
>
> `64bit IO Format:%lld`
>
> 题目描述：
>
> > 对给定的二叉树依次完成前序，中序，后序遍历，并输出遍历结果。
> >
> > 每行输入为一个二叉树，一维数组形式。其中 -1 表示 `Nil` 节点，例如：1，7，2，6，-1，4，8 构成的二叉树如下图所示：
> >
> > ```bash
> >      1
> >   7      2
> > 6  nil  4   8
> > ```
> >
> > 结果以二维数组形式输出（前序，中序，后序遍历的结果），其中 `Nil` 节点不用输出。
>
> 输入：
>
> > [1,7,2,6,-1,4,8]
>
> 输出：
>
> > [[1,7,6,2,4,8],[6,7,1,4,2,8],[6,7,4,8,2,1]]
>
> ==说明：==
>
> > 注意二维数组中的结果依次为（前序，中序，后序遍历的结果），其中 `Nil`（-1） 节点不用输出。
> >
>

  #### 微众银行2021年秋招数据应用研发卷

- 节奏小师

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 262144 `K`，其他语言 524288 `K`
>
> `64bit IO Format:%lld`
>
> 题目描述：
>
> > 现在你在玩一款游戏，叫做节奏小师。它有三种判定：
> >
> > `P`：`Perfect`，完美，加200分；
> >
> > `G`：`Great`，很棒，加100分；
> >
> > `M`：`Miss` 错过，不加分也不减分，但累计三次 `Miss` 就会输掉游戏。
> >
> > 另外有一种奖励是连击奖励，一旦连续三个 `Perfect` 之后，后续连击的 `Perfect` 分数将变成250分，但一旦打出了 `Great` 或者 `Miss` 则连击数将重新开始计算。
> >
> > 你的任务是根据游戏记录计算分数，特别地，失败记为零分。
>
> 输入：
>
> > `PPPPPGPPMP`
>
> 输出：
>
> > 1800
>

- 数字的重排列

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 262144 `K`，其他语言 524288 `K`
>
> `64bit IO Format:%lld`
>
> 题目描述：
>
> > 给定一个数不包含前导0点数 `n`，现在将 `n` 的各位数字进行顺序重组，在这些数中，有多少个数是 `m` 的倍数？例如112，重组后有三个数：112，121，211 
>
> 输入：
>
> > 112  4
>
> 输出：
>
> > 1
>
> ==说明：==
>
> > 数据范围：$n{\le}10^{18},1{\le}m{\le}100$



#### 华为 `OD`（`202010OD` 考试试卷）

- 一星题（找终点）

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 65536 `K`，其他语言 131072 `K`
>
> `64bit IO Format:%lld`
>
> 题目描述：
>
> > 给定一个正整数数组，设为 `nums`，最大为100个成员，求从第一个成员开始，正好走到数组最后一个成员，所使用的最少步骤数。
> >
> > 要求：
> >
> > 1、第一步必须从第一元素开始，且 `1<=第一步的步长 <= len/2`；（`len` 为数组的长度，需要自行解析）。
> >
> > 2、从第二步开始，只能以所在成员的数字走相应的步数，不能多也不能少，如果目标不可达返回-1，只输出最少的步骤数量。
> >
> > 3、只能向数组的尾部走，不能往回走。
>
> 输入描述：
>
> > 由正整数组成的数组，以空格分隔，数组长度小于100，请自行解析数据数量。
>
> 输出描述：
>
> > 正整数，表示最少的步数，如果不存在输出-1。
>
> 输入：
>
> > 7 5 9 4 2 6 8 3 5 4 3 9
>
> 输出：
>
> > 2

​	`AC` 代码：

```java
import java.util.Scanner;

/**
 * 找终点
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2021/4/18 16:07
 */
public class Hw041801 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String[] strings = sc.nextLine().split(" ");
        int[] array = new int[strings.length];
        for (int i = 0; i < strings.length; i++) {
            array[i] = Integer.valueOf(strings[i]);
        }

        int dst = Integer.MAX_VALUE;
        // 计算第二步开始的最少步数达到终点
        for (int i = 1; i < array.length / 2; i++) {
            int d = getNumber(array, i);
            // 第一步任意，不受限制
            if (d != -1) {
                dst = Math.min(dst, d);
            }
        }

        dst = dst == Integer.MAX_VALUE ? -1 : dst;
        System.out.println(dst);
    }

    private static int getNumber(int[] array, int i) {
        int step = 1;
        while (i < array.length) {
            i += array[i];
            step++;
            if (i == array.length - 1) {
                return step;
            }

            if (i > array.length - 1) {
                return -1;
            }
        }

        return -1;
    }
}
```


- 一星题（报数游戏）

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 65536 `K`，其他语言 131072 `K`
>
> `64bit IO Format:%lld`
>
> 题目描述：
>
> > 100个人围成一圈，每个人有一个编码，编号从1开始到100，他们从1开始一次报数，报到为 `M` 的人自动退出圈圈，然后下一个人接着从1开始报数，直到剩余的人数小于 `M`。请问最后剩余的人在原先的编号为多少？	
>
> 输入描述：
>
> > 输入一个整数参数 `M`
>
> 输出描述：
>
> > 如果输入参数 `M` 小于等于1或者大于等于100，输出 “`ERROR!`”；否则按照原先的编号从小到大的顺序，以英文逗号分隔输出编号字符串。
>
> 输入：
>
> > 3
> >
> > 4
>
> 输出：
>
> > 58,91
> >
> > 34,45,97

`AC` （0.8）代码：

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * 报数游戏 (80%)
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2021/4/18 16:07
 */
public class Hw041802 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int max = 100;
        if (m <= 1 || m >= max) {
            System.out.println("ERROR!");
            System.exit(1);
        }

        List<Integer> array = new ArrayList<>(16);
        for (int i = 0; i < max; i++) {
            array.add(i + 1);
        }

        int k = 1, index = 0;
        while (array.size() >= m) {
            k++;
            index++;
            if (index >= array.size()) {
                index = index - array.size();
            }

            if (k % m == 0) {
                System.out.println(array.get(index));
                array.remove(index);
                k = 1;
            }
        }

        StringBuilder sb = new StringBuilder();
        for (int j = 0; j < array.size(); j++) {
            sb.append(array.get(j));
            if (j != array.size() - 1) {
                sb.append(",");
            }
        }

        System.out.println(sb.toString());
    }

}
```


- 二星题（字符串比较）

> 时间限制：`C/C++` 1秒，其他语言2秒
>
> 空间限制：`C/C++` 65536 `K`，其他语言 131072 `K`
>
> `64bit IO Format:%lld`
>
> 题目描述：
>
> > 给定字符串 `A`，`B` 和正整数 `V`，`A` 的长度与 `B` 的长度相等，请计算 `A` 满足如下条件的最大连续子串的长度：
> >
> > 1、该连续子串在 `A` 和 `B` 中的位置和长度均相同。
> >
> > 2、该连续子串 `|A[i]-B[i]|` 之和小于等于 `V`，其中 `|A[i]-B[i]|` 表示两个字母 `ASCII` 码之差的绝对值。
>
> 输入描述：
>
> > 输入为三行：
> >
> > 第一行为字符串 `A`，仅包含小写字符，$$1\le A.length \le 1000$$。
> >
> > 第一行为字符串 `B`，仅包含小写字符，$$1\le B.length \le 1000$$。
> >
> > 第一行为正整数 `V`，$$1\le V \le 10000$$。
>
> 输出描述：
>
> > 字符串最大连续子串的长度，要求该子串 `|A[i]-B[i]|` 之和小于等于 `V`。
>
> 输入：
>
> > `xxcdefg`
> > `cdefghi`
> > `5`
>
> 输出：
>
> > 2

```java
import java.util.Scanner;

/**
 * 字符串比较
 *
 * 示例：xxcdefg
 *      cdefghi
 *      5
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2021/4/18 16:07
 */
public class Hw041803 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String a = sc.nextLine();
        String b = sc.nextLine();
        int v = sc.nextInt();
        StringBuilder sb = new StringBuilder();

        // 最长子串的起始位置，及其长度
        int start = -1, end = -1, max = 0;
        // 步长差
        int diff;
        int i = 0;
        while (i < a.length()) {
            diff = Math.abs(a.charAt(i) - b.charAt(i));
            if (diff > v) {
                i++;
                continue;
            }

            // 当前子串起始位置及总差之和
            int curStart = i, sum = diff;
            while (sum <= v && i < a.length()) {
                i++;
                if (i >= a.length()) {
                    break;
                }

                diff = Math.abs(a.charAt(i) - b.charAt(i));
                if (diff + sum > v) {
                    break;
                } else {
                    sum += diff;
                }
            }

            if (max < sum) {
                max = sum;
                start = curStart;
                end = i - 1;
            }
        }

        System.out.println(end - start + 1);
    }
}
```

## 剑指offer 

应聘者需要具备的素质：

> 1）基础知识扎实全面，包括编程语言，数据结构，算法等；
>
> 2）能写出正确的，完整的，鲁棒性的高质量代码；
>
> 3）能思路清晰地分析、解决复杂问题；
>
> 4）能从时间、空间复杂度两个方面优化算法效率；
>
> 5）具备优秀的沟通能力，学习能力，发散思维能力等。

#### 题3，数组中重复的数字（☑️）

> 原题链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof

**题目描述**

> 在一个长度为 $n$ 的数组 $nums$ 里的所有数字都在 $0$ ~ $n-1$ 的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。

**思路分析**

> 通过阅读提干，不难发现，题目要求是从已知数组中找到重复元素即可。这里列出三种解题思路仅作参考：
>
> > 1）最容易想到的算法自然是先排序后通过依次遍历并与后一个元素相比较找出第一个重复元素即可，易想到但是算法代价大不可取，最优时间复杂度为 $O(nlogn)$ ；
> >
> > 2）利用数据结构--`hash`结构，依次遍历数组中每一个元素，同时将元素放入`hash`中，在放入前先做判断：如果在`hash`存在则说明找到重复元素，否则放入`hash`中，直到遍历完所有元素为止，其时间复杂度为 $O(n)$ ，空间复杂度为 $O(n)$ ；
> >
> > 3）充分利用已知条件“数组里的所有数字都在 $0$ ~ $n-1$ 的范围内”，通过交换元素位置比较可以发现是否有重复元素，为本题最优解，其时间复杂度为 $O(n)$ ：
> >
> > > （1）原地改动数组，空间复杂度为 $O(1)$ ；
> > >
> > > （2）定义新数组，空间复杂度为 $O(n)$ 。

**参考代码**

- 方法一：复制数组，时间复杂度为 $O(n)$ ，空间复杂度为 $O(n)$ 。

````java
class Solution {
    public int findRepeatNumber(int[] nums) {
        int[] arr = new int[nums.length];
        for(int i = 0; i < nums.length; i++) {
            arr[nums[i]]++;
            if (arr[nums[i]] > 1 ) {
                return nums[i];
            }
        }

        return -1;
    }
}
````

运行结果如下：

![复制数组](images/leetcode_20200508234733.png)

- 方法二：原地修改数组，时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != i) {
                if (nums[nums[i]] == nums[i]) {
                    return nums[i];
                }
                
                int temp = nums[nums[i]];
                nums[nums[i]] = nums[i];
                nums[i] = temp;
            }
        }

        return -1;
    }
}
```

运行结果如下：

![原地修改数组](images/leetcode_20200508234657.png)

#### 题4，二维数组中的查找

> 原题链接：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/

**题目描述：**

> 在一个 $n * m$ 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**思路分析：**

> 方法一：暴力解，双循环遍历二维数组，其时间复杂为 $O(n^2)$ ；
>
> 方法二：题目已明确数组按行按列的递增规律，

**参考代码：**

- 方法一：暴力解，其时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if (matrix.length < 1) {
            return false;
        }

        int row = 0;
        int col = matrix[0].length - 1;
        while (row < matrix.length && col >= 0) {
            if (target == matrix[row][col]) {
                return true;
            }
            
            if (target < matrix[row][col]) {
                col--;
            } else {
                row++;
            }
        }
        
        return false;
    }
}
```

#### 题5，替换空格

1）首先遍历字符串求出空格个数；在Java中，String属于不可变类型，需要转换成char数组进行处理；

2）对char数组进行扩容，由‘%20’替代‘ ’，实际上是原字符数组长度增加空格数**2，即tail=length+countBlanks**2；

3）对字符数组进行由后向前的遍历处理：标记两个下标length（原字符数组长度）-1（记p）表示原字符数组的末位字符，tail(扩容后字符数组长度)-1（记q）表示扩容后字符数组的末尾字符；如果p指向的字符为空，则需要作替换处理（q前填充‘0’，‘2’，‘%’并向前移动3，p向前移动1），反之p，q均向前移动1，如此下去，直到p与q指向同一个位置，说明空格已全部替换完成。

```java
public String replaceSpace(String s) {
    int length = s.length();
    char[] chars = s.toCharArray();
    
    int countBlanks = 0;
    for (char ch: chars) { 
        if (ch == ' ') { 
            countBlanks++;
        } 
    }
    
    int tail = length + countBlanks * 2;
    chars = Arrays.copyOf(chars, tail);
    while (length != tail) { 
        if (chars[length - 1] != ' ') { 
            chars[tail - 1] = chars[length - 1];
            length--;
            tail--; 
        } else { 
            chars[tail - 1] = '0';
            chars[tail - 2] = '2';
            chars[tail - 3] = '%';
            length--;
            tail -= 3; 
        } 
    }
  
    return new String(chars);
}
```

#### 题6，从尾到头打印链表

解法一：栈思想

遍历链表，同时利用ArrayList结构（add(index,value)方法相当于压栈操作）存储每一个节点的value，然后将ArrayList通过循环遍历赋值给数组。时间复杂度和空间复杂度均为O(n)。

```java
class Solution {
    public int[] reversePrint(ListNode head) {
        List<Integer> arrayList = new ArrayList();
        while (head != null) {
            arrayList.add(0, head.val);
            head = head.next;
        }
        
        int[] array = new int[arrayList.size()];
        int i = 0;
        for (int item: arrayList) {
            array[i++] = item;
        }
        
        return array;
    }
}
```

- 解法二：递归法

```java
class Solution {
    List<Integer> list = new ArrayList();
    public int[] reversePrint(ListNode head) {
        if (head != null && head.next != null) {
            reversePrint(head.next);
        }
        
        if (head != null) {
            list.add(head.val);
        }

        int i = 0;
        int[] array = new int[list.size()];
        for(int item : list) {
            array[i++] = item;
        }
        return array;
    }
}
```

#### 题11，旋转数组的最小数字

```java
/**
 * 面试题11. 旋转数组的最小数字
 * 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
 * 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。
 * 例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。
 *
 * 示例 1：
 * 输入：[3,4,5,1,2]
 * 输出：1
 *
 * 示例 2：
 * 输入：[2,2,2,0,1]
 * 输出：0
 *
 * @author zhangbocheng
 */
public class Solution {
    public int minArray(int[] numbers) {
        if (numbers == null || numbers.length < 1) {
            throw new ArithmeticException("Empty array!");
        }

        int low = 0, high = numbers.length - 1;
        int mid;
        while (low < high) {
            mid = (low + high) / 2;
            if (numbers[mid] > numbers[high]) {
                low = mid + 1;
            } else if (numbers[mid] < numbers[high])  {
                high = mid;
            } else {
                high--;
            }
        }

        return numbers[low];
    }
}
```

#### 题25，合并两个有序链表

```java
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode merge, p, q, s;
        merge = new ListNode(0);
        s = merge;  // 用一个新节点指向一个新链表，关键点
        p = list1;
        q = list2;

        while(p != null && q != null) {
            if (p.val < q.val) {
                s.next = p;
                p = p.next;
            } else {
                s.next = q;
                q = q.next;
            }
            s = s.next;
        }

        s.next = p !=null ? p : q;
        return merge.next;
    }
}
```

#### 题58 - I. 翻转单词顺序

```java
/**
 * 面试题58 - I. 翻转单词顺序
 * 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。
 * 为简单起见，标点符号和普通字母一样处理。
 * 例如输入字符串"I am a student. "，则输出"student. a am I"。
 *
 * 示例 1：
 * 输入: "the sky is blue"
 * 输出: "blue is sky the"
 *
 * 示例 2：
 * 输入: "  hello world!  "
 * 输出: "world! hello"
 * 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
 *
 * 示例 3：
 * 输入: "a good   example"
 * 输出: "example good a"
 * 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
 *
 * @author zhangbocheng
 */
class Solution {
    public String reverseWords(String s) {
        if (s == null || s.length() < 1) {
            return s;
        }
        
        String[] words = s.trim().split(" ");
        StringBuilder str = new StringBuilder();
        for (int i = words.length - 1; i >= 0; i--) {
            if ("".equals(words[i])) {
                continue;
            }

            str.append(words[i]);
            str.append(" ");
        }
        
        return str.toString().trim();
    }
}
```

#### 题58 - II. 左旋转字符串

- 方法一

```java
/**
 * 面试题58 - II. 左旋转字符串
 * 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。
 * 请定义一个函数实现字符串左旋转操作的功能。
 * 比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。
 *
 * 示例 1：
 * 输入: s = "abcdefg", k = 2
 * 输出: "cdefgab"
 *
 * 示例 2：
 * 输入: s = "lrloseumgh", k = 6
 * 输出: "umghlrlose"
 *
 * 限制：
 * 1 <= k < s.length <= 10000
 *
 * @author zhangbocheng
 */
class Solution {
    public String reverseLeftWords(String s, int n) {
        if (s == null || s.length() < 1
                || s.length() < n || n < 1 || s.length() > 10000) {
            return null;
        }

        StringBuilder sb = new StringBuilder();
        sb.append(s.substring(n, s.length()));
        sb.append(s.substring(0, n));
        return sb.toString();
    }
}
```

- 方法二，三步反转法

```java
/**
 * 面试题58 - II. 左旋转字符串
 * 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。
 * 请定义一个函数实现字符串左旋转操作的功能。
 * 比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。
 *
 * 示例 1：
 * 输入: s = "abcdefg", k = 2
 * 输出: "cdefgab"
 *
 * 示例 2：
 * 输入: s = "lrloseumgh", k = 6
 * 输出: "umghlrlose"
 *
 * 限制：
 * 1 <= k < s.length <= 10000
 *
 * @author zhangbocheng
 */
class Solution {
   public String reverseLeftWords(String s, int n) {
        if (s == null || s.length() < 1
                || s.length() < n || n < 1 || s.length() > 10000) {
            return null;
        }

        String s1 = reverseString(s.substring(0, n));
        String s2 = reverseString(s.substring(n, s.length()));
        return reverseString(s1.concat(s2));
    }

    public String reverseString(String s) {
        StringBuilder sb = new StringBuilder();
        sb.append(s).reverse();
        return sb.toString();
    }
}
```

#### 题29，顺时针打印矩阵

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if (matrix == null || matrix.length < 1) {
            return new int[0];
        }

        int start = 0, number = 2, count = 0;
        int rowLength = matrix.length;
        int colLength = matrix[0].length;
        int[] array = new int[rowLength * colLength];
        // 遍历一周，行数和列数均减小2
        while (start * number < rowLength && start * number < colLength) {
            int endX = rowLength - start - 1;
            int endY = colLength - start - 1;
            // top row
            for (int i = start; i <= endY; i++) {
                array[count++] = matrix[start][i];
            }
            // right column
            for (int j = start + 1; j <= endX; j++) {
                array[count++] = matrix[j][endY];
            }
            // bottom column，endX控制单行情况
            for (int k = endY - 1; endX > start && k >= start; k--) {
                array[count++] = matrix[endX][k];
            }
            // left column, endY控制单列情况
            for (int m = endX - 1; endY > start && m > start; m--) {
                array[count++] = matrix[m][start];
            }
            start++;
        }

        return array;
    }
}
```

#### 题64. 

> 原题链接：

**题目描述**

**思路分析**

**参考代码**

运行结果如下：

![转字符串法]

#### 题64. 求1+2+…+n（☑️）

> 原题链接：https://leetcode-cn.com/problems/qiu-12n-lcof/

**题目描述**

> 求 `1+2+...+n` ，要求不能使用乘除法、`for`、`while`、`if`、`else`、`switch`、`case` 等关键字及条件判断语句（`A?B:C`）。

**思路分析**

> 本题抛开要求限制，算是入门级题目，但是加上条件限制却变成了一道思维拓展题，不涉及任何算法知识。这里给出两种解决方案：
>
> 方法一：递归法，递归需要判断终止条件，除了 `if` 语句，还有 `switch`，逻辑运算符，进而可以突破 `if` 的限制，达到解题目的；
>
> 方法二：等差数列求和公式，$$S_{n}=\frac{(1+n)*n}{2}$$，这里出现了乘除法，现在就需要想方设法找道乘除法的替代方案，除法可以用位运算替代；乘法呢？将分子展开即有 $$n^2 + n$$，平方可以调用库函数 `pow`。

**参考代码**

- 方法一：递归法，其时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public int sumNums(int n) {
        int sum = n;
        boolean flag = n > 0 && (sum += sumNums(n - 1)) > 0;
        return sum;
    }
}
```

运行结果如下：

![递归法](images/leetcode_20200602003011.png)

- 方法二：等差数列公式，其时间复杂度为 $O(1)$ ，空间复杂度为 $O(1)$ 。

```java
class Solution {
    public int sumNums(int n) {
        return ((int)Math.pow(n, 2) + n) >> 1;
    }
}
```

运行结果如下：

![等差数列公式](images/leetcode_20200602113841.png)



## 面试宝典

#### 1. 

> 原题链接：

**题目描述**

> 

**思路分析**

> 

**参考代码**

方法一：暴力优化解法，其时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$。

运行结果如下：

![]()

#### 题10.01. 合并排序的数组 

> 原题链接：https://leetcode-cn.com/problems/sorted-merge-lcci/

**题目描述**

> 给定两个排序后的数组 `A` 和 `B`，其中 `A` 的末端有足够的缓冲空间容纳 `B`。 编写一个方法，将 `B` 合并入 `A` 并排序。
>
> 初始化 `A` 和 `B` 的元素数量分别为 `m` 和 `n`。
>
> 示例:
>
> > 输入:
> >
> > ```
> > A = [1,2,3,0,0,0], m = 3
> > B = [2,5,6],       n = 3
> > ```
> >
> > 输出: 
> >
> > ```
> > [1,2,2,3,5,6]
> > ```
>
> 说明:
>
> ```
> A.length == n + m
> ```

**思路分析**

> 方法一：（双指针法）利用双指针方法合并两个数组，从数组的尾部开始向前遍历并逐步比较插入，属于基础解法， 需要注意的点是数组 `A` 初始可能为空数组。

**参考代码**

方法一：双指针法 ，其时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        if (B == null || B.length < 1) {
            return;
        }

        int i = m - 1, j = n - 1, cnt = m + n - 1;
        while (j >= 0) {
            if (i < 0 || A[i] <= B[j]) {
                A[cnt--] = B[j--];
            } else {
                A[cnt--] = A[i--];
            }
        } 
    }
}
```

运行结果如下：

![双指针法](images/leetcode_20200923102652.png)

## 经典算法

#### 0，概述

![常见的内部排序](images/sort_20201002%20232339.png)

![常见的内部排序详细](images/sort_20201002232340.png)

```java
package com.leetcode;

import java.util.List;

/**
 * 排序
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/10/27 17:26
 */
public class Sort {

    static void printArray(int[] array) {
        for (int item : array) {
            System.out.printf("%d ", item);
        }
        System.out.println();
    }

    static void printArrays(List<List<Integer>> arrays) {
        for (List<Integer> array: arrays) {
            System.out.print("[ ");
            for (Integer item: array) {
                System.out.printf("%d ", item);
            }
            System.out.print("]");
        }

        System.out.println();
    }
}
```

#### 1，冒泡排序

基本思想：

> 重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从 `Z` 到 `A`）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。

![bubbleSort](images/bubbleSort.gif)

代码实现：

```java
package com.leetcode;

/**
 * 冒泡排序
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/10/10 17:26
 */
public class SortBubble extends Sort {

    public static void bubbleSort(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }

        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
            printArray(array);
        }
    }

    public static void main(String[] args) {
        int[] array = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
        bubbleSort(array);
        printArray(array);
    }
}
```

#### 2，选择排序

基本思想：

>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

![selectionSort](images/selectionSort.gif)

代码实现：

```java
package com.leetcode;

/**
 * 选择排序
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/10/10 17:26
 */
public class SortSelection extends Sort {

    public static void selectionSort(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }

        for (int i = 0; i < array.length; i++) {
            int minIndex = i;
            for (int j = i + 1; j < array.length; j++) {
                if (array[i] > array[j]) {
                    minIndex = j;
                }
            }

            int temp = array[i];
            array[i] = array[minIndex];
            array[minIndex] = temp;

            printArray(array);
        }
    }

    public static void main(String[] args) {
        int[] array = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
        selectionSort(array);
        printArray(array);
    }

}
```

#### 3，插入排序

基本思想：

> 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

![insertionSort](images/insertionSort.gif)

代码实现：

```java
package com.leetcode;

/**
 * 直接插入排序
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/10/10 17:26
 */
public class SortInsert extends Sort {

    public static void insertSort(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }

        int i, j, key;
        for (i = 1; i < array.length; i++) {
            if (array[i] < array[i - 1]) {
                key = array[i];
                array[i] = array[i - 1];
                for (j = i - 1; j >= 0 && key < array[j]; j--) {
                    array[j + 1] = array[j];
                }
                array[j + 1] = key;
            }

            printArray(array);
        }
    }

    public static void main(String[] args) {
        int[] array = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
        insertSort(array);
        printArray(array);
    }
}
```

#### 4，希尔排序

基本思想：

> 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。

![shellSort](images/Sorting_shellsort_anim.gif)

代码实现：

```java
package com.leetcode;

/**
 * 希尔排序
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/10/27 17:26
 */
public class SortShell extends Sort {

    private static void shellSort(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }

        int dk = 1;
        while (dk < array.length) {
            dk = dk * 3 + 1;
        }

        while (dk > 0) {
            for (int i = dk; i < array.length; i++) {
                int temp = array[i];
                int j = i - dk;
                while (j >= 0 && array[j] > temp) {
                    array[j + dk] = array[j];
                    j -= dk;
                }

                array[j + dk] = temp;
            }

            dk = (int) Math.floor((double) dk / 3);
            printArray(array);
        }
    }

    public static void main(String[] args) {
        int[] array = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
        shellSort(array);
        printArray(array);
    }

}
```

#### 5，归并排序

基本思想：

> 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。

![mergeSort](images/mergeSort.gif)

代码实现：

```java
package com.leetcode;

import com.datastructure.Sort;
import java.util.Arrays;

/**
 * 归并排序
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/10/27 17:26
 */
public class SortMerge extends Sort {

    private static int[] mergeSort(int[] array) {
        if (array == null || array.length <= 1) {
            return array;
        }

        int middle = (int) Math.floor(array.length / 2.0);
        int[] left = Arrays.copyOfRange(array, 0, middle);
        int[] right = Arrays.copyOfRange(array, middle, array.length);

        return merge(mergeSort(left), mergeSort(right));
    }

    private static int[] merge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0;
        while (left.length > 0 && right.length > 0) {
            if (left[0] <= right[0]) {
                result[i++] = left[0];
                left = Arrays.copyOfRange(left, 1, left.length);
            } else {
                result[i++] = right[0];
                right = Arrays.copyOfRange(right, 1, right.length);
            }
        }

        while (left.length > 0) {
            result[i++] = left[0];
            left = Arrays.copyOfRange(left, 1, left.length);
        }

        while (right.length > 0) {
            result[i++] = right[0];
            right = Arrays.copyOfRange(right, 1, right.length);
        }

        printArray(result);
        
        return result;
    }

    public static void main(String[] args) {
        int[] array = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
        printArray(array);
        printArray(mergeSort(array));
    }

}
```

#### 6，快速排序

基本思想：

> 通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

![quickSort](images/quickSort.gif)

代码实现：

```java
package com.leetcode;

/**
 * 快速排序
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/10/10 17:26
 */
public class SortQuick extends Sort {

    private static void quickSort(int[] array, int low, int high) {
        if (array == null || array.length <= 1) {
            return;
        }

        if (low < high) {
            int pos = partition(array, low, high);
            printArray(array);
            quickSort(array, low, pos - 1);
            quickSort(array, pos + 1, high);
        }
    }

    private static int partition(int[] array, int low, int high) {
        int key = array[low];
        while (low < high) {
            while (low < high && Math.abs(array[high]) >= Math.abs(key)) {
                high--;
            }
            array[low] = array[high];

            while (low < high && Math.abs(array[low]) <= Math.abs(key)) {
                low++;
            }
            array[high] = array[low];
        }

        array[low] = key;
        return low;
    }

    public static void main(String[] args) {
        int[] array = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
        quickSort(array, 0, array.length - 1);
        printArray(array);
    }

}
```

#### 7，堆排序

基本思想：

> **堆排序**（`Heapsort`）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：
>
> > 1）大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
> >
> > 2）小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列。
>
> 在堆的数据结构数据结构)中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：
>
> > 最大堆调整（`Max Heapify`）：将堆的末端子节点作调整，使得子节点永远小于父节点；
> >
> > 创建最大堆（`Build Max Heap`）：将堆中的所有数据重新排序；
> >
> > 堆排序（`HeapSort`）：移除位在第一个数据的根节点，并做最大堆调整的递归运算。

![headSort](images/heapSort.gif)

代码实现：

```java
package com.leetcode;


/**
 * 堆排序
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/10/29 17:26
 */
public class SortHeap extends Sort {

    private static void headSort(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }

        int length = array.length;
        buildHeap(array);
        printArray(array);
        for (int i = length - 1; i >= 0; i--) {
            swap(array, 0, i);
            length--;
            heapify(array, 0, length);
            printArray(array);
        }

    }

    private static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    private static void heapify(int[] array, int i, int length) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int largest = i;
        if (left < length && array[left] > array[largest]) {
            largest = left;
        }

        if (right < length && array[right] > array[largest]) {
            largest = right;
        }

        if (largest != i) {
            swap(array, i, largest);
            heapify(array, largest, length);
        }
    }

    private static void buildHeap(int[] array) {
        int i = (int) Math.floor(array.length / 2.0);
        while (i >= 0) {
            heapify(array, i, array.length);
            i--;
        }
    }

    public static void main(String[] args) {
        int[] array = {91, 60, 96, 13, 35, 65, 46, 65, 10, 30, 20, 77, 81, 22};
        headSort(array);
        printArray(array);
    }

}
```

#### 8，计数排序

基本思想：

> 计数排序的 **核心** 在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
>
> 当输入的元素是 $n$ 个 0 到 $k$ 之间的整数时，它的运行时间是 ${\theta}(n + k)$。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 $C$ 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。

![countingSort](images/countingSort.gif)

代码实现：

```java
package com.leetcode;


/**
 * 计数排序
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/10/29 17:26
 */
public class SortCounting extends Sort {

    private static void countSort(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }

        int maxValue = getMaxValue(array);
        countingSort(array, maxValue);
    }

    private static void countingSort(int[] array, int maxValue) {
        int bucketLength = maxValue + 1;
        int[] bucket = new int[bucketLength];

        for (int val: array) {
            bucket[val]++;
        }

        printArray(bucket);

        int index = 0;
        for (int i = 0; i < bucketLength; i++) {
            while (bucket[i] > 0) {
                array[index++] = i;
                bucket[i]--;
            }
        }
    }

    private static int getMaxValue(int[] array) {
        int max = array[0];
        for (int i = 1; i < array.length; i++) {
            max = Math.max(max, array[i]);
        }

        return max;
    }

    public static void main(String[] args) {
        int[] array = {2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2};
        printArray(array);
        countSort(array);
        printArray(array);
    }

}
```

#### 9，桶排序

基本思想：

> 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，需要做到：
>
> > 1）在额外空间充足的情况下，尽量增大桶的数量；
> >
> > 2）使用的映射函数能够将输入的 $N$ 个数据均匀的分配到 $K$ 个桶中。

![bucketSort](images/bucketSort.png)

代码实现：

```java
package com.leetcode;

import com.datastructure.Sort;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * 桶排序
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/10/29 16:31
 */
public class SortBucket extends Sort {

    public static void bucketSort(int[] array) {
         
        if (array == null || array.length <= 1) {
            return;
        }
    
        int max = array[0], min = array[0];
        for (int item: array) {
            max = Math.max(max, item);
            min = Math.min(min, item);
        }

        int bucketNumber = (max - min) / array.length + 1;
        List<List<Integer>> buckets = new ArrayList<>(bucketNumber);
        for (int i = 0; i < bucketNumber; i++) {
            buckets.add(new ArrayList<>(16));
        }

        for (int item: array) {
            int num = (int) Math.floor((double) (item - min) / array.length);
            buckets.get(num).add(item);
        }

        printArrays(buckets);

        for (List<Integer> bucket : buckets) {
            Collections.sort(bucket);
        }

        printArrays(buckets);

        int index = 0;
        for (List<Integer> bucket : buckets) {
            for (Integer integer : bucket) {
                array[index++] = integer;
            }
        }
    }

    public static void main(String[] args) {
        int[] array = {2, 3, 8, 7, 1, 25, 2, 2, 27, 39, 29, 49, 8, 2, 1, 4, 2, 4, 6, 9, 2, 50};
        printArray(array);
        bucketSort(array);
        printArray(array);
    }

}
```

#### 10，基数排序

基本思想：

> 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。
>
> 基数排序 `vs` 计数排序 `vs` 桶排序：这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：
>
> > 基数排序：根据键值的每位数字来分配桶；
> >
> > 计数排序：每个桶只存储单一键值；
> >
> > 桶排序：每个桶存储一定范围的数值。

![radixSort](images/radixSort.gif)

代码实现：

```java
package com.leetcode;

import com.datastructure.Sort;
import java.util.ArrayList;
import java.util.List;

/**
 * 基数排序
 *
 * @author zhangbocheng
 * @version v1.0
 * @date 2020/10/29 16:31
 */
public class SortRadix extends Sort {

    public static void radixSort(int[] array) {

        if (array == null || array.length <= 1) {
            return;
        }

        int maxDigit = getMaxDigit(array);

        int mod = 10, dev = 1;
        for (int i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {
            List<List<Integer>> counter = new ArrayList<>(mod * 2);
            for (int j = 0; j < mod * 2; j++) {
                counter.add(new ArrayList<>(16));
            }

            for (int k : array) {
                int bucket = ((k % mod) / dev) + mod;
                counter.get(bucket).add(k);
            }

            printArrays(counter);

            int pos = 0;
            for (List<Integer> bucket: counter) {
                for (int value: bucket) {
                    array[pos++] = value;
                }
            }
        }
    }

    private static int getMaxDigit(int[] array) {
        int max = getMaxValue(array);
        return getNumberLength(max);
    }

    private static int getNumberLength(int num) {
        if (num == 0) {
            return 1;
        }

        int length = 0;
        for (long i = num; i != 0; i /= 10) {
            length++;
        }

        return length;
    }

    private static int getMaxValue(int[] array) {

        int max = array[0];
        for (int item: array) {
            max = Math.max(max, item);
        }

        return max;
    }

    public static void main(String[] args) {
        int[] array = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48};
        printArray(array);
        radixSort(array);
        printArray(array);
    }

}
```

## 题型归纳

#### 1，数组类算法

1）移动零【[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)】

2）移除元素【[27. 移除元素](https://leetcode-cn.com/problems/remove-element/)】

3）删除排序数组中的重复项【[26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)】

4）删除排序数组中的重复项 II【[80. 删除排序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)】

5）颜色分类【[75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)】

6）数组中的第K个最大元素【[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)】

7）合并两个有序数组【[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)】

8）两数之和 II - 输入有序数组【[167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)】

9）验证回文串【[125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)】

10）反转字符串中的元音字母【[345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)】

11）盛最多水的容器【[11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)】

12）长度最小的子数组【[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)】


## 知识点补充

#### 1，蔡勒公式

**蔡勒公式**（`Zeller's congruence`），是一种计算任何一日属一星期中哪一日的算法，由德国数学家克里斯提安·蔡勒推算出来。
$$
{\displaystyle w=\left(y+\left[{\frac {y}{4}}\right]+\left[{\frac {c}{4}}\right]-2c+\left[{\frac {26(m+1)}{10}}\right]+d-1\right){\bmod {7}}}
$$

$$
{\displaystyle w=\left(y+\left[{\frac {y}{4}}\right]+\left[{\frac {c}{4}}\right]-2c+2m+\left[{\frac {3(m+1)}{5}}\right]+d+1\right){\bmod {7}}}
$$

公式都是基于公历的置闰规则来考虑。

公式中的符号含义如下：

- `w`：星期（计算所得的数值对应的星期：0-星期日；1-星期一；2-星期二；3-星期三；4-星期四；5-星期五；6-星期六）
- `c`：年份前两位数
- `y`：年份后两位数
- `m`：月（`m` 的取值范围为3至14，即在蔡勒公式中，某年的1、2月要看作上一年的13、14月来计算，比如2003年1月1日要看作2002年的13月1日来计算）
- `d`：日
- `[　]`：称作高斯符号，代表向下取整，即，取不大于原数的最大整数
- `mod`：同余（这里代表括号里的答案除以7后的余数）


## 参考资料

- [十大经典排序算法](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)
- [【排序】图解桶排序](https://blog.csdn.net/qq_27124771/article/details/87651495)
- [排序算法系列：基数排序](https://blog.csdn.net/lemon_tree12138/article/details/51695211)
- [蔡勒公式](https://zh.wikipedia.org/wiki/%E8%94%A1%E5%8B%92%E5%85%AC%E5%BC%8F)

